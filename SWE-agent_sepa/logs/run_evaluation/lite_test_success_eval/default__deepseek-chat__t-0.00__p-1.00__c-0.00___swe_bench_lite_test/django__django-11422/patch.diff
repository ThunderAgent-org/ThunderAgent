diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py
index 7ca0d68fae..aa12389233 100644
--- a/django/utils/autoreload.py
+++ b/django/utils/autoreload.py
@@ -579,6 +579,10 @@ def run_with_reloader(main_func, *args, **kwargs):
     try:
         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':
             reloader = get_reloader()
+            # Add the main script (manage.py) to the watched files
+            main_script = Path(sys.argv[0]).resolve()
+            if main_script.exists() and hasattr(reloader, 'watch_file'):
+                reloader.watch_file(main_script)
             logger.info('Watching for file changes with %s', reloader.__class__.__name__)
             start_django(reloader, main_func, *args, **kwargs)
         else:
diff --git a/test_autoreload.py b/test_autoreload.py
new file mode 100644
index 0000000000..dbb9a9182e
--- /dev/null
+++ b/test_autoreload.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python
+"""Test script to reproduce the autoreload issue with manage.py"""
+
+import os
+import sys
+import tempfile
+import shutil
+from pathlib import Path
+
+# Add the testbed to the path
+sys.path.insert(0, '/testbed')
+
+from django.utils.autoreload import StatReloader, iter_all_python_module_files
+
+def test_autoreload():
+    # Create a temporary directory structure
+    with tempfile.TemporaryDirectory() as tmpdir:
+        # Create a simple manage.py file
+        manage_py = Path(tmpdir) / "manage.py"
+        manage_py.write_text("""
+#!/usr/bin/env python
+import os
+import sys
+
+def main():
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test.settings')
+    print('manage.py executed')
+
+if __name__ == '__main__':
+    main()
+""")
+        
+        # Create a simple settings.py file
+        settings_py = Path(tmpdir) / "settings.py"
+        settings_py.write_text("""
+DEBUG = True
+""")
+        
+        # Change to the temporary directory
+        original_cwd = os.getcwd()
+        os.chdir(tmpdir)
+        
+        try:
+            # Add the temporary directory to sys.path
+            sys.path.insert(0, tmpdir)
+            
+            # Import the manage module
+            import manage
+            
+            # Initialize the autoreloader
+            reloader = StatReloader()
+            
+            # Get the watched files
+            watched_files = list(reloader.watched_files())
+            
+            print("Watched files:")
+            for file in watched_files:
+                print(f"  {file}")
+            
+            # Check if manage.py is in the watched files
+            manage_py_path = Path(manage_py).resolve().absolute()
+            print(f"\nmanage.py path: {manage_py_path}")
+            print(f"Is manage.py watched? {manage_py_path in watched_files}")
+            
+            # Also check what iter_all_python_module_files returns
+            module_files = list(iter_all_python_module_files())
+            print(f"\nModule files from iter_all_python_module_files:")
+            for file in module_files:
+                print(f"  {file}")
+            print(f"Is manage.py in module files? {manage_py_path in module_files}")
+            
+        finally:
+            # Restore original state
+            os.chdir(original_cwd)
+            if tmpdir in sys.path:
+                sys.path.remove(tmpdir)
+
+if __name__ == '__main__':
+    test_autoreload()
\ No newline at end of file
diff --git a/test_autoreload_fix.py b/test_autoreload_fix.py
new file mode 100644
index 0000000000..84ebe3ffd4
--- /dev/null
+++ b/test_autoreload_fix.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python
+"""Test the actual autoreload fix"""
+
+import os
+import sys
+import tempfile
+from pathlib import Path
+
+# Add the testbed to the path
+sys.path.insert(0, '/testbed')
+
+# Import the modified run_with_reloader function
+from django.utils.autoreload import run_with_reloader
+
+def dummy_main():
+    """Dummy main function for testing"""
+    print("Dummy main function executed")
+    # Don't run indefinitely for testing
+    return
+
+def test_run_with_reloader_fix():
+    # Create a temporary directory structure
+    with tempfile.TemporaryDirectory() as tmpdir:
+        # Create a simple manage.py file
+        manage_py = Path(tmpdir) / "manage.py"
+        manage_py.write_text("""
+#!/usr/bin/env python
+import os
+import sys
+
+def main():
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test.settings')
+    print('manage.py executed')
+
+if __name__ == '__main__':
+    main()
+""")
+        
+        # Change to the temporary directory
+        original_cwd = os.getcwd()
+        os.chdir(tmpdir)
+        
+        # Save original argv
+        original_argv = sys.argv
+        
+        try:
+            # Set sys.argv[0] to our manage.py file
+            sys.argv = [str(manage_py)]
+            
+            # Set the autoreload environment variable
+            os.environ['RUN_MAIN'] = 'true'
+            
+            print("Testing run_with_reloader with manage.py...")
+            print(f"sys.argv[0]: {sys.argv[0]}")
+            
+            # This should trigger our fix
+            # We need to catch the SystemExit that happens when the reloader starts
+            try:
+                run_with_reloader(dummy_main)
+            except SystemExit as e:
+                # This is expected - the reloader exits when the main function completes
+                print(f"SystemExit caught (expected): {e}")
+            
+        finally:
+            # Restore original state
+            os.chdir(original_cwd)
+            sys.argv = original_argv
+            if 'RUN_MAIN' in os.environ:
+                del os.environ['RUN_MAIN']
+
+if __name__ == '__main__':
+    test_run_with_reloader_fix()
\ No newline at end of file
diff --git a/test_autoreload_integration.py b/test_autoreload_integration.py
new file mode 100644
index 0000000000..3d41e78fe8
--- /dev/null
+++ b/test_autoreload_integration.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python
+"""Integration test for the autoreload fix"""
+
+import os
+import sys
+import tempfile
+from pathlib import Path
+
+# Add the testbed to the path
+sys.path.insert(0, '/testbed')
+
+from django.utils.autoreload import get_reloader
+
+def test_autoreload_integration():
+    # Create a temporary directory structure
+    with tempfile.TemporaryDirectory() as tmpdir:
+        # Create a simple manage.py file
+        manage_py = Path(tmpdir) / "manage.py"
+        manage_py.write_text("""
+#!/usr/bin/env python
+import os
+import sys
+
+def main():
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test.settings')
+    print('manage.py executed')
+
+if __name__ == '__main__':
+    main()
+""")
+        
+        # Change to the temporary directory
+        original_cwd = os.getcwd()
+        os.chdir(tmpdir)
+        
+        # Save original argv
+        original_argv = sys.argv
+        
+        try:
+            # Set sys.argv[0] to our manage.py file
+            sys.argv = [str(manage_py)]
+            
+            # Set the autoreload environment variable
+            os.environ['RUN_MAIN'] = 'true'
+            
+            # Get the reloader (this is what happens in run_with_reloader)
+            reloader = get_reloader()
+            
+            # Our fix should add the main script to the watched files
+            # Let's check if it's in the extra_files set
+            print("Extra files in reloader:")
+            for file in reloader.extra_files:
+                print(f"  {file}")
+            
+            # Check if manage.py is in the extra files
+            manage_py_path = Path(manage_py).resolve().absolute()
+            print(f"\nmanage.py path: {manage_py_path}")
+            print(f"Is manage.py in extra_files? {manage_py_path in reloader.extra_files}")
+            
+            # Get all watched files
+            watched_files = list(reloader.watched_files())
+            print(f"Is manage.py in watched_files? {manage_py_path in watched_files}")
+            
+        finally:
+            # Restore original state
+            os.chdir(original_cwd)
+            sys.argv = original_argv
+            if 'RUN_MAIN' in os.environ:
+                del os.environ['RUN_MAIN']
+
+if __name__ == '__main__':
+    test_autoreload_integration()
\ No newline at end of file
diff --git a/test_autoreload_real.py b/test_autoreload_real.py
new file mode 100644
index 0000000000..3833f7edac
--- /dev/null
+++ b/test_autoreload_real.py
@@ -0,0 +1,90 @@
+#!/usr/bin/env python
+"""Test script to reproduce the autoreload issue with manage.py in a more realistic scenario"""
+
+import os
+import sys
+import tempfile
+import shutil
+from pathlib import Path
+
+# Add the testbed to the path
+sys.path.insert(0, '/testbed')
+
+from django.utils.autoreload import StatReloader, iter_all_python_module_files, check_errors
+
+def simulate_main_function():
+    """Simulate the main function that would be run by runserver"""
+    print("Simulating main function execution...")
+    # This is where the Django app would be initialized
+    # For our test, we just need to simulate that manage.py was executed
+    pass
+
+def test_autoreload_real():
+    # Create a temporary directory structure
+    with tempfile.TemporaryDirectory() as tmpdir:
+        # Create a simple manage.py file
+        manage_py = Path(tmpdir) / "manage.py"
+        manage_py.write_text("""
+#!/usr/bin/env python
+import os
+import sys
+
+def main():
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test.settings')
+    print('manage.py executed')
+
+if __name__ == '__main__':
+    main()
+""")
+        
+        # Create a simple settings.py file
+        settings_py = Path(tmpdir) / "settings.py"
+        settings_py.write_text("""
+DEBUG = True
+""")
+        
+        # Change to the temporary directory
+        original_cwd = os.getcwd()
+        os.chdir(tmpdir)
+        
+        try:
+            # Add the temporary directory to sys.path
+            sys.path.insert(0, tmpdir)
+            
+            # Simulate what happens when runserver starts
+            # The main function is wrapped with check_errors
+            wrapped_main = check_errors(simulate_main_function)
+            
+            # Execute the wrapped main function
+            wrapped_main()
+            
+            # Now check what files are being watched
+            reloader = StatReloader()
+            watched_files = list(reloader.watched_files())
+            
+            print("\nWatched files after main function execution:")
+            for file in watched_files:
+                print(f"  {file}")
+            
+            # Check if manage.py is in the watched files
+            manage_py_path = Path(manage_py).resolve().absolute()
+            print(f"\nmanage.py path: {manage_py_path}")
+            print(f"Is manage.py watched? {manage_py_path in watched_files}")
+            
+            # Check what's in sys.modules
+            print(f"\nModules in sys.modules that contain 'manage':")
+            for module_name in sys.modules:
+                if 'manage' in module_name:
+                    module = sys.modules[module_name]
+                    print(f"  {module_name}: {module}")
+                    if hasattr(module, '__file__'):
+                        print(f"    File: {module.__file__}")
+            
+        finally:
+            # Restore original state
+            os.chdir(original_cwd)
+            if tmpdir in sys.path:
+                sys.path.remove(tmpdir)
+
+if __name__ == '__main__':
+    test_autoreload_real()
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..5d70a7a306
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,105 @@
+#!/usr/bin/env python
+"""Test script to verify the autoreload fix for manage.py"""
+
+import os
+import sys
+import tempfile
+import time
+from pathlib import Path
+
+# Add the testbed to the path
+sys.path.insert(0, '/testbed')
+
+from django.utils.autoreload import StatReloader, run_with_reloader
+
+def test_main_function():
+    """Simulate the main function that would be run by runserver"""
+    print("Main function executed")
+    # Simulate a long-running server
+    time.sleep(5)
+
+def test_autoreload_fix():
+    # Create a temporary directory structure
+    with tempfile.TemporaryDirectory() as tmpdir:
+        # Create a simple manage.py file
+        manage_py = Path(tmpdir) / "manage.py"
+        manage_py.write_text("""
+#!/usr/bin/env python
+import os
+import sys
+
+def main():
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test.settings')
+    print('manage.py executed')
+
+if __name__ == '__main__':
+    main()
+""")
+        
+        # Change to the temporary directory
+        original_cwd = os.getcwd()
+        os.chdir(tmpdir)
+        
+        # Save original argv
+        original_argv = sys.argv
+        
+        try:
+            # Set sys.argv[0] to our manage.py file
+            sys.argv = [str(manage_py)]
+            
+            # Initialize the autoreloader
+            reloader = StatReloader()
+            
+            # Add the main script to the watched files (this is what our fix does)
+            main_script = Path(sys.argv[0]).resolve()
+            if main_script.exists():
+                reloader.watch_file(main_script)
+            
+            # Get the watched files
+            watched_files = list(reloader.watched_files())
+            
+            print("Watched files after adding main script:")
+            for file in watched_files:
+                print(f"  {file}")
+            
+            # Check if manage.py is in the watched files
+            manage_py_path = Path(manage_py).resolve().absolute()
+            print(f"\nmanage.py path: {manage_py_path}")
+            print(f"Is manage.py watched? {manage_py_path in watched_files}")
+            
+            # Test that the file change detection works
+            print("\nTesting file change detection...")
+            
+            # Get initial snapshot
+            initial_snapshot = list(reloader.snapshot_files())
+            manage_py_mtime = None
+            for file, mtime in initial_snapshot:
+                if file == manage_py_path:
+                    manage_py_mtime = mtime
+                    print(f"Initial mtime for manage.py: {mtime}")
+                    break
+            
+            # Modify the file
+            time.sleep(1)  # Ensure different mtime
+            with open(manage_py, 'a') as f:
+                f.write("# Modified\n")
+            
+            # Get new snapshot
+            new_snapshot = list(reloader.snapshot_files())
+            new_manage_py_mtime = None
+            for file, mtime in new_snapshot:
+                if file == manage_py_path:
+                    new_manage_py_mtime = mtime
+                    print(f"New mtime for manage.py: {mtime}")
+                    break
+            
+            if manage_py_mtime and new_manage_py_mtime:
+                print(f"File changed detected: {new_manage_py_mtime > manage_py_mtime}")
+            
+        finally:
+            # Restore original state
+            os.chdir(original_cwd)
+            sys.argv = original_argv
+
+if __name__ == '__main__':
+    test_autoreload_fix()
\ No newline at end of file
diff --git a/test_manage_py_fix.py b/test_manage_py_fix.py
new file mode 100644
index 0000000000..84435fdf4b
--- /dev/null
+++ b/test_manage_py_fix.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python
+"""Test to verify that manage.py is properly watched by the autoreloader"""
+
+import os
+import sys
+import tempfile
+from pathlib import Path
+
+# Add the testbed to the path
+sys.path.insert(0, '/testbed')
+
+from django.utils.autoreload import get_reloader, run_with_reloader
+
+def test_manage_py_watched():
+    """Test that manage.py is added to the watched files"""
+    
+    # Create a temporary directory structure
+    with tempfile.TemporaryDirectory() as tmpdir:
+        # Create a simple manage.py file
+        manage_py = Path(tmpdir) / "manage.py"
+        manage_py.write_text("""
+#!/usr/bin/env python
+import os
+import sys
+
+def main():
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test.settings')
+    print('manage.py executed')
+
+if __name__ == '__main__':
+    main()
+""")
+        
+        # Change to the temporary directory
+        original_cwd = os.getcwd()
+        os.chdir(tmpdir)
+        
+        # Save original argv
+        original_argv = sys.argv
+        
+        try:
+            # Set sys.argv[0] to our manage.py file
+            sys.argv = [str(manage_py)]
+            
+            # Set the autoreload environment variable
+            os.environ['RUN_MAIN'] = 'true'
+            
+            # Get the reloader (this is what happens in run_with_reloader)
+            reloader = get_reloader()
+            
+            # Check if manage.py is in the extra files (before our fix)
+            manage_py_path = Path(manage_py).resolve().absolute()
+            print(f"manage.py path: {manage_py_path}")
+            print(f"Is manage.py in extra_files (before fix)? {manage_py_path in reloader.extra_files}")
+            
+            # Now simulate what our fix does
+            main_script = Path(sys.argv[0]).resolve()
+            if main_script.exists() and hasattr(reloader, 'watch_file'):
+                reloader.watch_file(main_script)
+            
+            # Check if manage.py is in the extra files (after our fix)
+            print(f"Is manage.py in extra_files (after fix)? {manage_py_path in reloader.extra_files}")
+            
+            # Get all watched files
+            watched_files = list(reloader.watched_files())
+            print(f"Is manage.py in watched_files? {manage_py_path in watched_files}")
+            
+            # Verify the fix works
+            assert manage_py_path in reloader.extra_files, "manage.py should be in extra_files after fix"
+            assert manage_py_path in watched_files, "manage.py should be in watched_files after fix"
+            
+            print("\nâœ… Fix verified: manage.py is now properly watched by the autoreloader!")
+            
+        finally:
+            # Restore original state
+            os.chdir(original_cwd)
+            sys.argv = original_argv
+            if 'RUN_MAIN' in os.environ:
+                del os.environ['RUN_MAIN']
+
+if __name__ == '__main__':
+    test_manage_py_watched()
\ No newline at end of file
diff --git a/test_runserver_scenario.py b/test_runserver_scenario.py
new file mode 100644
index 0000000000..d799c117e2
--- /dev/null
+++ b/test_runserver_scenario.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python
+"""Test script to simulate the actual runserver scenario"""
+
+import os
+import sys
+import tempfile
+import time
+from pathlib import Path
+
+# Add the testbed to the path
+sys.path.insert(0, '/testbed')
+
+from django.utils.autoreload import run_with_reloader
+
+def simulate_inner_run():
+    """Simulate the inner_run function from runserver command"""
+    print("Simulating inner_run function...")
+    # Simulate a long-running server
+    time.sleep(10)
+
+def test_runserver_scenario():
+    # Create a temporary directory structure
+    with tempfile.TemporaryDirectory() as tmpdir:
+        # Create a simple manage.py file
+        manage_py = Path(tmpdir) / "manage.py"
+        manage_py.write_text("""
+#!/usr/bin/env python
+import os
+import sys
+
+def main():
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test.settings')
+    print('manage.py executed')
+
+if __name__ == '__main__':
+    main()
+""")
+        
+        # Change to the temporary directory
+        original_cwd = os.getcwd()
+        os.chdir(tmpdir)
+        
+        # Save original argv
+        original_argv = sys.argv
+        
+        try:
+            # Set sys.argv[0] to our manage.py file
+            sys.argv = [str(manage_py)]
+            
+            # Set the autoreload environment variable to simulate the reloader process
+            os.environ['RUN_MAIN'] = 'true'
+            
+            print("Testing autoreload with manage.py...")
+            print(f"sys.argv[0]: {sys.argv[0]}")
+            
+            # This will run the autoreloader with our fix
+            # We'll run it for a short time to test the setup
+            try:
+                # Run for a short time to test the setup
+                run_with_reloader(simulate_inner_run)
+            except SystemExit:
+                # Expected when the reloader exits
+                pass
+            
+        finally:
+            # Restore original state
+            os.chdir(original_cwd)
+            sys.argv = original_argv
+            if 'RUN_MAIN' in os.environ:
+                del os.environ['RUN_MAIN']
+
+if __name__ == '__main__':
+    test_runserver_scenario()
\ No newline at end of file
