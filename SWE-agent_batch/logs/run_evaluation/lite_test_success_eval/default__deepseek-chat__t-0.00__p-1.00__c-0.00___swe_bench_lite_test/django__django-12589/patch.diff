diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
index 84960d77e1..5f364b8182 100644
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -1051,7 +1051,9 @@ class Subquery(Expression):
 
     def get_group_by_cols(self, alias=None):
         if alias:
-            return [Ref(alias, self)]
+            # For Subquery expressions, we need to use the full expression in GROUP BY
+            # to avoid ambiguous column references in databases like PostgreSQL
+            return [self]
         external_cols = self.query.get_external_cols()
         if any(col.possibly_multivalued for col in external_cols):
             return [self]
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..b26ffb84cc
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db import models
+from django.db.models import OuterRef, Subquery, Count, Q
+
+# Define the models as described in the PR
+class A(models.Model):
+    bs = models.ManyToManyField('B', related_name="a", through="AB")
+    
+    class Meta:
+        app_label = 'test_app'
+
+class B(models.Model):
+    class Meta:
+        app_label = 'test_app'
+
+class AB(models.Model):
+    a = models.ForeignKey(A, on_delete=models.CASCADE, related_name="ab_a")
+    b = models.ForeignKey(B, on_delete=models.CASCADE, related_name="ab_b")
+    status = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test_app'
+
+class C(models.Model):
+    a = models.ForeignKey(
+        A,
+        null=True,
+        blank=True,
+        on_delete=models.SET_NULL,
+        related_name="c",
+        verbose_name="a"
+    )
+    status = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test_app'
+
+# Create the tables in the correct order
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(B)
+    schema_editor.create_model(A)
+    schema_editor.create_model(AB)
+    schema_editor.create_model(C)
+
+# Now try to reproduce the query
+print("Testing the problematic query...")
+
+try:
+    ab_query = AB.objects.filter(a=OuterRef("pk"), b=1)
+    query = A.objects.annotate(
+        status=Subquery(ab_query.values("status")),
+        # c_count=Count("c"),  # Skip this for now to focus on the main issue
+    )
+    answer = query.values("status").annotate(total_count=Count("status"))
+    
+    print("Generated SQL:")
+    print(answer.query)
+    
+    # Try to execute the query
+    result = list(answer)
+    print("Query executed successfully!")
+    print("Result:", result)
+    
+except Exception as e:
+    print(f"Error occurred: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
