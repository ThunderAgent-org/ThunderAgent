diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py
index f33bcbdccf..30648895df 100644
--- a/django/core/management/commands/inspectdb.py
+++ b/django/core/management/commands/inspectdb.py
@@ -133,6 +133,8 @@ class Command(BaseCommand):
                 known_models.append(table2model(table_name))
                 used_column_names = []  # Holds column names used in the table so far
                 column_to_field_name = {}  # Maps column names to names of model fields
+                # Track foreign key relations to generate related_name when needed
+                target_table_counts = {}  # Maps target table names to count of references
                 for row in table_description:
                     comment_notes = (
                         []
@@ -182,6 +184,17 @@ class Command(BaseCommand):
                             if ref_db_table == table_name
                             else table2model(ref_db_table)
                         )
+                        
+                        # Generate related_name if multiple foreign keys point to same table
+                        if rel_to != "self":  # Don't generate related_name for self-references
+                            # Count references to this target table
+                            target_table_counts[ref_db_table] = target_table_counts.get(ref_db_table, 0) + 1
+                            
+                            # If this is not the first reference to this table, generate related_name
+                            if target_table_counts[ref_db_table] > 1:
+                                # Use the field name as the related_name
+                                extra_params["related_name"] = att_name + "_rel"
+                        
                         if rel_to in known_models:
                             field_type = "%s(%s" % (rel_type, rel_to)
                         else:
diff --git a/test_related_name_issue.py b/test_related_name_issue.py
new file mode 100644
index 0000000000..1bbc0d0ac0
--- /dev/null
+++ b/test_related_name_issue.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python
+"""
+Test script to reproduce the related_name clash issue with inspectdb.
+This script creates a database table with multiple foreign keys to the same table
+and then runs inspectdb to see if it generates proper related_name attributes.
+"""
+
+import os
+import sys
+import tempfile
+from io import StringIO
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')
+
+import django
+from django.conf import settings
+from django.core.management import call_command
+from django.db import connection, models
+from django.db.models.base import ModelBase
+
+def setup_test_database():
+    """Create a test database with tables that have multiple foreign keys to the same table."""
+    
+    # Create a temporary model with multiple foreign keys to the same table
+    class TestModel(models.Model):
+        name = models.CharField(max_length=100)
+        
+        class Meta:
+            app_label = 'test_app'
+            db_table = 'test_model'
+    
+    class RelatedModel(models.Model):
+        # Multiple foreign keys to the same table - this should cause related_name clash
+        field1 = models.ForeignKey(TestModel, on_delete=models.CASCADE)
+        field2 = models.ForeignKey(TestModel, on_delete=models.CASCADE)
+        field3 = models.ForeignKey(TestModel, on_delete=models.CASCADE)
+        
+        class Meta:
+            app_label = 'test_app'
+            db_table = 'related_model'
+    
+    # Create the tables in the database
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(TestModel)
+        schema_editor.create_model(RelatedModel)
+    
+    return TestModel, RelatedModel
+
+def test_inspectdb_output():
+    """Run inspectdb and check if it generates proper related_name attributes."""
+    
+    # Setup the database
+    print("Setting up test database...")
+    TestModel, RelatedModel = setup_test_database()
+    
+    # Run inspectdb
+    print("\nRunning inspectdb...")
+    out = StringIO()
+    call_command('inspectdb', 'related_model', stdout=out)
+    output = out.getvalue()
+    
+    print("\nInspectdb output:")
+    print("=" * 80)
+    print(output)
+    print("=" * 80)
+    
+    # Check if related_name is generated
+    if 'related_name' in output:
+        print("\n✓ related_name attributes found in output")
+    else:
+        print("\n✗ No related_name attributes found in output")
+        
+    # Check for specific related_name patterns
+    lines = output.split('\n')
+    related_name_count = 0
+    for line in lines:
+        if 'related_name' in line:
+            related_name_count += 1
+            print(f"Found related_name: {line.strip()}")
+    
+    print(f"\nTotal related_name attributes found: {related_name_count}")
+    
+    # Cleanup
+    with connection.schema_editor() as schema_editor:
+        schema_editor.delete_model(RelatedModel)
+        schema_editor.delete_model(TestModel)
+
+if __name__ == '__main__':
+    # Configure Django
+    if not settings.configured:
+        settings.configure(
+            DATABASES={
+                'default': {
+                    'ENGINE': 'django.db.backends.sqlite3',
+                    'NAME': ':memory:',
+                }
+            },
+            INSTALLED_APPS=[
+                'django.contrib.contenttypes',
+                'django.contrib.auth',
+            ],
+            USE_TZ=True,
+        )
+    
+    django.setup()
+    
+    # Run the test
+    test_inspectdb_output()
\ No newline at end of file
