diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 8837881579..576cbdbf10 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -678,10 +678,20 @@ class Query(BaseExpression):
         "target", and the model and list of fields being added for that model.
         """
         field_names, defer = self.deferred_loading
-        if not field_names:
-            return
         orig_opts = self.get_meta()
-        seen = {}
+        
+        # If we're not in defer mode and field_names is empty, it means "load all fields"
+        # In this case, we return early without processing any field restrictions.
+        if not field_names and not defer:
+            return
+        
+        # If we're in defer mode with an empty set, it means we want to defer
+        # all fields except the primary key. We need to handle this case.
+        if not field_names and defer:
+            # Skip the field processing loop and handle this case in the defer branch
+            seen = {}
+        else:
+            seen = {}
         must_include = {orig_opts.concrete_model: {orig_opts.pk}}
         for field_name in field_names:
             parts = field_name.split(LOOKUP_SEP)
@@ -718,11 +728,21 @@ class Query(BaseExpression):
             # slight complexity here is handling fields that exist on parent
             # models.
             workset = {}
-            for model, values in seen.items():
-                for field in model._meta.local_fields:
-                    if field not in values:
-                        m = field.model._meta.concrete_model
-                        add_to_dict(workset, m, field)
+            
+            # Check if we're in the special case of defer mode with empty field_names
+            if not field_names:
+                # We want to defer all fields except the primary key
+                # So we only include the primary key in the workset
+                pk_model = orig_opts.concrete_model
+                add_to_dict(workset, pk_model, orig_opts.pk)
+            else:
+                # Original logic
+                for model, values in seen.items():
+                    for field in model._meta.local_fields:
+                        if field not in values:
+                            m = field.model._meta.concrete_model
+                            add_to_dict(workset, m, field)
+            
             for model, values in must_include.items():
                 # If we haven't included a model in workset, we don't add the
                 # corresponding must_include fields for that model, since an
@@ -2066,7 +2086,7 @@ class Query(BaseExpression):
 
     def clear_deferred_loading(self):
         """Remove any fields from the deferred loading set."""
-        self.deferred_loading = (frozenset(), True)
+        self.deferred_loading = (frozenset(), False)
 
     def add_deferred_loading(self, field_names):
         """
@@ -2086,7 +2106,12 @@ class Query(BaseExpression):
             self.deferred_loading = existing.union(field_names), True
         else:
             # Remove names from the set of any existing "immediate load" names.
-            self.deferred_loading = existing.difference(field_names), False
+            new_existing = existing.difference(field_names)
+            # If we've removed all fields from immediate loading, switch to defer mode
+            if not new_existing:
+                self.deferred_loading = frozenset(), True
+            else:
+                self.deferred_loading = new_existing, False
 
     def add_immediate_loading(self, field_names):
         """
diff --git a/test_defer_behavior.py b/test_defer_behavior.py
new file mode 100644
index 0000000000..76e899b37e
--- /dev/null
+++ b/test_defer_behavior.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python
+"""Test script to understand the defer/only behavior"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a simple Company model
+class Company(models.Model):
+    name = models.CharField(max_length=100)
+    trade_number = models.CharField(max_length=100)
+    country = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the tables
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Company)
+
+# Test the defer/only behavior
+print("Testing defer/only behavior...")
+print("=" * 60)
+
+# Test case 1: Basic defer behavior
+print("\nTest 1: Company.objects.defer('name')")
+qs1 = Company.objects.defer("name")
+print(f"SQL: {qs1.query}")
+
+# Test case 2: Basic only behavior
+print("\nTest 2: Company.objects.only('name')")
+qs2 = Company.objects.only("name")
+print(f"SQL: {qs2.query}")
+
+# Test case 3: only().defer() chaining
+print("\nTest 3: Company.objects.only('name', 'country').defer('name')")
+qs3 = Company.objects.only("name", "country").defer("name")
+print(f"SQL: {qs3.query}")
+
+# Test case 4: only().defer() with all fields deferred
+print("\nTest 4: Company.objects.only('name').defer('name')")
+qs4 = Company.objects.only("name").defer("name")
+print(f"SQL: {qs4.query}")
+
+# Test case 5: only().defer().defer() chaining
+print("\nTest 5: Company.objects.only('name').defer('name').defer('country')")
+qs5 = Company.objects.only("name").defer("name").defer("country")
+print(f"SQL: {qs5.query}")
+
+# Let's also check the deferred fields
+print("\n" + "=" * 60)
+print("Checking deferred fields:")
+
+# Create a test instance
+company = Company.objects.create(name="Test", trade_number="123", country="US")
+
+# Test case 4 deferred fields
+obj4 = qs4.first()
+print(f"Test 4 deferred fields: {obj4.get_deferred_fields()}")
+
+# Test case 5 deferred fields
+obj5 = qs5.first()
+print(f"Test 5 deferred fields: {obj5.get_deferred_fields()}")
\ No newline at end of file
diff --git a/test_defer_debug.py b/test_defer_debug.py
new file mode 100644
index 0000000000..129ebd6c92
--- /dev/null
+++ b/test_defer_debug.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python
+"""Debug script to understand the defer/only issue"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a simple Company model
+class Company(models.Model):
+    name = models.CharField(max_length=100)
+    trade_number = models.CharField(max_length=100)
+    country = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the tables
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Company)
+
+# Let's debug the deferred_to_data method
+print("Debugging deferred_to_data method...")
+print("=" * 60)
+
+# Test case 1: Company.objects.only("name").defer("name")
+print("\nTest 1: Company.objects.only('name').defer('name')")
+qs1 = Company.objects.only("name").defer("name")
+
+# Let's manually call deferred_to_data to see what it returns
+target = {}
+qs1.query.deferred_to_data(target, qs1.query.get_loaded_field_names_cb)
+print("deferred_to_data result:", target)
+
+# Test case 2: Company.objects.only("name").defer("name").defer("country")
+print("\nTest 2: Company.objects.only('name').defer('name').defer('country')")
+qs2 = Company.objects.only("name").defer("name").defer("country")
+
+target = {}
+qs2.query.deferred_to_data(target, qs2.query.get_loaded_field_names_cb)
+print("deferred_to_data result:", target)
+
+# Test case 3: Company.objects.only("name", "country").defer("name")
+print("\nTest 3: Company.objects.only('name', 'country').defer('name')")
+qs3 = Company.objects.only("name", "country").defer("name")
+
+target = {}
+qs3.query.deferred_to_data(target, qs3.query.get_loaded_field_names_cb)
+print("deferred_to_data result:", target)
\ No newline at end of file
diff --git a/test_defer_debug2.py b/test_defer_debug2.py
new file mode 100644
index 0000000000..a90cd96ebb
--- /dev/null
+++ b/test_defer_debug2.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python
+"""Debug script to understand the defer/only issue"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a simple Company model
+class Company(models.Model):
+    name = models.CharField(max_length=100)
+    trade_number = models.CharField(max_length=100)
+    country = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the tables
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Company)
+
+# Let's debug the deferred_to_data method
+print("Debugging deferred_to_data method...")
+print("=" * 60)
+
+# Test case 1: Company.objects.only("name").defer("name")
+print("\nTest 1: Company.objects.only('name').defer('name')")
+qs1 = Company.objects.only("name").defer("name")
+
+print("deferred_loading:", qs1.query.deferred_loading)
+
+# Let's manually call deferred_to_data to see what it returns
+target = {}
+qs1.query.deferred_to_data(target, qs1.query.get_loaded_field_names_cb)
+print("deferred_to_data result:", target)
+
+# Let's also check what fields are being selected
+print("Default columns:", qs1.query.get_compiler('default').get_default_columns())
\ No newline at end of file
diff --git a/test_defer_issue.py b/test_defer_issue.py
new file mode 100644
index 0000000000..bc21d8ebb9
--- /dev/null
+++ b/test_defer_issue.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python
+"""Test script to reproduce the defer/only issue"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a simple Company model
+class Company(models.Model):
+    name = models.CharField(max_length=100)
+    trade_number = models.CharField(max_length=100)
+    country = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the tables
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Company)
+
+# Test the issue
+print("Testing defer/only issue...")
+print("=" * 60)
+
+# Test case 1: Company.objects.only("name").defer("name")
+print("\nTest 1: Company.objects.only('name').defer('name')")
+print("Expected: SELECT 'company'.'id' FROM 'company'")
+qs1 = Company.objects.only("name").defer("name")
+print(f"Actual SQL: {qs1.query}")
+
+# Test case 2: Company.objects.only("name").defer("name").defer("country")
+print("\nTest 2: Company.objects.only('name').defer('name').defer('country')")
+print("Expected: SELECT 'company'.'id' FROM 'company'")
+qs2 = Company.objects.only("name").defer("name").defer("country")
+print(f"Actual SQL: {qs2.query}")
+
+# Test case 3: Company.objects.only("name", "country").defer("name")
+print("\nTest 3: Company.objects.only('name', 'country').defer('name')")
+print("Expected: SELECT 'company'.'id', 'company'.'country' FROM 'company'")
+qs3 = Company.objects.only("name", "country").defer("name")
+print(f"Actual SQL: {qs3.query}")
+
+# Let's also check the deferred_loading attribute
+print("\n" + "=" * 60)
+print("Checking deferred_loading attribute:")
+print("\nTest 1 deferred_loading:", qs1.query.deferred_loading)
+print("Test 2 deferred_loading:", qs2.query.deferred_loading)
+print("Test 3 deferred_loading:", qs3.query.deferred_loading)
\ No newline at end of file
diff --git a/test_defer_none.py b/test_defer_none.py
new file mode 100644
index 0000000000..9aee4aec5a
--- /dev/null
+++ b/test_defer_none.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python
+"""Test script to understand the defer(None) issue"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a simple Company model
+class Company(models.Model):
+    name = models.CharField(max_length=100)
+    trade_number = models.CharField(max_length=100)
+    country = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the tables
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Company)
+
+# Test the defer(None) behavior
+print("Testing defer(None) behavior...")
+print("=" * 60)
+
+# Test case: Company.objects.defer("name", "value").defer(None)
+print("\nTest: Company.objects.defer('name', 'trade_number').defer(None)")
+qs = Company.objects.defer("name", "trade_number").defer(None)
+
+print("deferred_loading:", qs.query.deferred_loading)
+
+# Let's manually call deferred_to_data to see what it returns
+target = {}
+qs.query.deferred_to_data(target, qs.query.get_loaded_field_names_cb)
+print("deferred_to_data result:", target)
+
+# Check what fields are being selected
+print("SQL:", qs.query)
\ No newline at end of file
