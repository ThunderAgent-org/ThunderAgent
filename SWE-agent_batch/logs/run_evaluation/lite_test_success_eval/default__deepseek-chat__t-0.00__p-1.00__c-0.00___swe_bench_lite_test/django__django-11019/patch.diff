diff --git a/analyze_constraints.py b/analyze_constraints.py
new file mode 100644
index 0000000000..94e4b27325
--- /dev/null
+++ b/analyze_constraints.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python
+"""Analyze the ordering constraints in the merge algorithm"""
+
+import warnings
+
+class MediaOrderConflictWarning(RuntimeWarning):
+    pass
+
+def analyze_constraints(list_1, list_2):
+    """Analyze the ordering constraints from both lists"""
+    
+    # Extract ordering constraints from list_1
+    constraints_1 = []
+    for i in range(len(list_1)):
+        for j in range(i + 1, len(list_1)):
+            constraints_1.append((list_1[i], list_1[j]))
+    
+    # Extract ordering constraints from list_2
+    constraints_2 = []
+    for i in range(len(list_2)):
+        for j in range(i + 1, len(list_2)):
+            constraints_2.append((list_2[i], list_2[j]))
+    
+    # Combine constraints
+    all_constraints = constraints_1 + constraints_2
+    
+    print("Constraints from list_1:")
+    for a, b in constraints_1:
+        print(f"  {a} must come before {b}")
+    
+    print("\nConstraints from list_2:")
+    for a, b in constraints_2:
+        print(f"  {a} must come before {b}")
+    
+    print("\nAll constraints:")
+    for a, b in all_constraints:
+        print(f"  {a} must come before {b}")
+    
+    # Check for circular dependencies
+    from collections import defaultdict
+    
+    graph = defaultdict(list)
+    for a, b in all_constraints:
+        graph[a].append(b)
+    
+    # Check for cycles using DFS
+    def has_cycle(node, visited, rec_stack):
+        visited.add(node)
+        rec_stack.add(node)
+        
+        for neighbor in graph.get(node, []):
+            if neighbor not in visited:
+                if has_cycle(neighbor, visited, rec_stack):
+                    return True
+            elif neighbor in rec_stack:
+                return True
+        
+        rec_stack.remove(node)
+        return False
+    
+    visited = set()
+    rec_stack = set()
+    
+    for node in graph:
+        if node not in visited:
+            if has_cycle(node, visited, rec_stack):
+                print("\nCIRCULAR DEPENDENCY DETECTED!")
+                return True
+    
+    print("\nNo circular dependencies detected")
+    return False
+
+# Test the problematic case
+list_1 = ['color-picker.js', 'text-editor.js']
+list_2 = ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']
+
+print("Analyzing constraints for the problematic case:")
+print("list_1:", list_1)
+print("list_2:", list_2)
+print()
+
+has_circular = analyze_constraints(list_1, list_2)
+
+if has_circular:
+    print("\nThe constraints are contradictory!")
+    print("We have:")
+    print("  color-picker.js must come before text-editor.js (from list_1)")
+    print("  text-editor.js must come before text-editor-extras.js (from list_2)")
+    print("  text-editor-extras.js must come before color-picker.js (from list_2)")
+    print("\nThis creates a cycle: color-picker.js -> text-editor.js -> text-editor-extras.js -> color-picker.js")
+    
+    # The algorithm should warn about the actual conflicting pair
+    # In this case, the conflict is between color-picker.js and text-editor.js
+    # because list_1 says color-picker.js comes first, but list_2 implies text-editor.js comes first
+    print("\nThe correct warning should be about color-picker.js and text-editor.js")
+else:
+    print("\nNo circular dependencies found")
\ No newline at end of file
diff --git a/debug_merge.py b/debug_merge.py
new file mode 100644
index 0000000000..91bae78c0d
--- /dev/null
+++ b/debug_merge.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python
+"""Debug script to understand the merge algorithm"""
+
+import warnings
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=False,
+        USE_L10N=False,
+        USE_TZ=False,
+    )
+    django.setup()
+
+from django.forms.widgets import Media
+
+# Capture warnings
+warnings.simplefilter("always")
+
+# Let's manually trace through the merge algorithm
+list_1 = ['color-picker.js', 'text-editor.js']
+list_2 = ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']
+
+print("list_1:", list_1)
+print("list_2:", list_2)
+print("Processing list_2 in reverse order...")
+
+# Start with a copy of list_1.
+combined_list = list(list_1)
+last_insert_index = len(list_1)
+print(f"Initial combined_list: {combined_list}")
+print(f"Initial last_insert_index: {last_insert_index}")
+
+# Walk list_2 in reverse, inserting each element into combined_list if
+# it doesn't already exist.
+for i, path in enumerate(reversed(list_2)):
+    print(f"\n--- Processing element {i+1}: '{path}' ---")
+    print(f"combined_list before: {combined_list}")
+    print(f"last_insert_index before: {last_insert_index}")
+    
+    try:
+        # Does path already exist in the list?
+        index = combined_list.index(path)
+        print(f"'{path}' found at index {index}")
+    except ValueError:
+        # Add path to combined_list since it doesn't exist.
+        print(f"'{path}' not found, inserting at index {last_insert_index}")
+        combined_list.insert(last_insert_index, path)
+        print(f"combined_list after insertion: {combined_list}")
+    else:
+        if index > last_insert_index:
+            print(f"WARNING: index ({index}) > last_insert_index ({last_insert_index})")
+            print(f"Would warn about: {combined_list[last_insert_index]} and {combined_list[index]}")
+        else:
+            print(f"No warning: index ({index}) <= last_insert_index ({last_insert_index})")
+        # path already exists in the list. Update last_insert_index so
+        # that the following elements are inserted in front of this one.
+        last_insert_index = index
+        print(f"Updated last_insert_index to: {last_insert_index}")
+
+print(f"\nFinal combined_list: {combined_list}")
+
+# Now let's test the actual Media merge
+print("\n" + "="*50)
+print("Testing actual Media.merge() method:")
+
+result = Media.merge(list_1, list_2)
+print(f"Media.merge result: {result}")
\ No newline at end of file
diff --git a/fixed_merge.py b/fixed_merge.py
new file mode 100644
index 0000000000..638bb1e00e
--- /dev/null
+++ b/fixed_merge.py
@@ -0,0 +1,88 @@
+#!/usr/bin/env python
+"""Fixed version of the merge algorithm"""
+
+import warnings
+
+class MediaOrderConflictWarning(RuntimeWarning):
+    pass
+
+def merge_fixed(list_1, list_2):
+    """
+    Fixed version of the merge algorithm.
+    The key insight: last_insert_index should only be updated when we insert a new element,
+    not when we find an existing element.
+    """
+    # Start with a copy of list_1.
+    combined_list = list(list_1)
+    last_insert_index = len(list_1)
+    
+    # Walk list_2 in reverse, inserting each element into combined_list if
+    # it doesn't already exist.
+    for path in reversed(list_2):
+        try:
+            # Does path already exist in the list?
+            index = combined_list.index(path)
+        except ValueError:
+            # Add path to combined_list since it doesn't exist.
+            combined_list.insert(last_insert_index, path)
+            # Update last_insert_index to the position where we inserted
+            # This ensures subsequent insertions happen before this one
+            last_insert_index = combined_list.index(path)
+        else:
+            # path already exists in the list.
+            # Check if this creates a conflict with previously inserted elements
+            if index > last_insert_index:
+                warnings.warn(
+                    'Detected duplicate Media files in an opposite order:\n'
+                    '%s\n%s' % (combined_list[last_insert_index], combined_list[index]),
+                    MediaOrderConflictWarning,
+                )
+            # Don't update last_insert_index when we find an existing element
+            # Only update it when we insert a new element
+    
+    return combined_list
+
+# Test the fixed algorithm
+print("Testing fixed merge algorithm:")
+
+# The problematic case from the PR
+list_1 = ['color-picker.js', 'text-editor.js']
+list_2 = ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']
+
+print("list_1:", list_1)
+print("list_2:", list_2)
+
+result = merge_fixed(list_1, list_2)
+print(f"Fixed result: {result}")
+print(f"Expected: ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']")
+
+# Let's trace through the fixed algorithm
+print("\nTracing through the fixed algorithm:")
+combined_list = list(list_1)
+last_insert_index = len(list_1)
+print(f"Initial combined_list: {combined_list}")
+print(f"Initial last_insert_index: {last_insert_index}")
+
+for i, path in enumerate(reversed(list_2)):
+    print(f"\n--- Processing element {i+1}: '{path}' ---")
+    print(f"combined_list before: {combined_list}")
+    print(f"last_insert_index before: {last_insert_index}")
+    
+    try:
+        index = combined_list.index(path)
+        print(f"'{path}' found at index {index}")
+        if index > last_insert_index:
+            print(f"WARNING: index ({index}) > last_insert_index ({last_insert_index})")
+            print(f"Would warn about: {combined_list[last_insert_index]} and {combined_list[index]}")
+        else:
+            print(f"No warning: index ({index}) <= last_insert_index ({last_insert_index})")
+        # Don't update last_insert_index
+    except ValueError:
+        print(f"'{path}' not found, inserting at index {last_insert_index}")
+        combined_list.insert(last_insert_index, path)
+        # Update last_insert_index to where we inserted
+        last_insert_index = combined_list.index(path)
+        print(f"combined_list after insertion: {combined_list}")
+        print(f"Updated last_insert_index to: {last_insert_index}")
+
+print(f"\nFinal combined_list: {combined_list}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..705b159322
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python
+"""Script to reproduce the MediaOrderConflictWarning issue"""
+
+import warnings
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=False,
+        USE_L10N=False,
+        USE_TZ=False,
+    )
+    django.setup()
+
+from django import forms
+
+# Capture warnings
+warnings.simplefilter("always")
+
+class ColorPicker(forms.Widget):
+    class Media:
+        js = ['color-picker.js']
+
+class SimpleTextWidget(forms.Widget):
+    class Media:
+        js = ['text-editor.js']
+
+class FancyTextWidget(forms.Widget):
+    class Media:
+        js = ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']
+
+class MyForm(forms.Form):
+    background_color = forms.CharField(widget=ColorPicker())
+    intro = forms.CharField(widget=SimpleTextWidget())
+    body = forms.CharField(widget=FancyTextWidget())
+
+# Test the form media
+print("Testing MyForm().media:")
+form = MyForm()
+print(f"Media: {form.media}")
+print(f"JS files: {form.media._js}")
+
+# Let's also test the intermediate steps to understand the issue
+print("\nTesting intermediate steps:")
+color_picker_media = ColorPicker().media
+simple_text_media = SimpleTextWidget().media
+fancy_text_media = FancyTextWidget().media
+
+print(f"ColorPicker media: {color_picker_media}")
+print(f"SimpleTextWidget media: {simple_text_media}")
+print(f"FancyTextWidget media: {fancy_text_media}")
+
+# Test the problematic addition
+print("\nTesting ColorPicker().media + SimpleTextWidget().media:")
+combined_1 = color_picker_media + simple_text_media
+print(f"Combined 1: {combined_1}")
+print(f"Combined 1 JS: {combined_1._js}")
+
+# Test the final combination
+print("\nTesting (ColorPicker().media + SimpleTextWidget().media) + FancyTextWidget().media:")
+combined_final = combined_1 + fancy_text_media
+print(f"Final combined: {combined_final}")
+print(f"Final combined JS: {combined_final._js}")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..9a3e3e830e
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python
+"""Test script to verify the fix"""
+
+import warnings
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=False,
+        USE_L10N=False,
+        USE_TZ=False,
+    )
+    django.setup()
+
+from django.forms.widgets import Media
+
+# Capture warnings
+warnings.simplefilter("always")
+
+# Test case from the PR description
+list_1 = ['color-picker.js', 'text-editor.js']
+list_2 = ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']
+
+print("Testing the problematic merge:")
+print("list_1:", list_1)
+print("list_2:", list_2)
+
+result = Media.merge(list_1, list_2)
+print(f"Result: {result}")
+print(f"Expected: ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']")
+
+# Let's also test some edge cases
+print("\n" + "="*50)
+print("Testing edge cases:")
+
+# Case 1: No conflicts
+print("\nCase 1: No conflicts")
+list_a = ['a.js', 'b.js']
+list_b = ['c.js', 'd.js']
+result = Media.merge(list_a, list_b)
+print(f"merge({list_a}, {list_b}) = {result}")
+
+# Case 2: Simple conflict
+print("\nCase 2: Simple conflict")
+list_a = ['a.js', 'b.js']
+list_b = ['b.js', 'a.js']
+result = Media.merge(list_a, list_b)
+print(f"merge({list_a}, {list_b}) = {result}")
+
+# Case 3: The original problem case
+print("\nCase 3: Original problem case")
+list_a = ['color-picker.js', 'text-editor.js']
+list_b = ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']
+result = Media.merge(list_a, list_b)
+print(f"merge({list_a}, {list_b}) = {result}")
\ No newline at end of file
