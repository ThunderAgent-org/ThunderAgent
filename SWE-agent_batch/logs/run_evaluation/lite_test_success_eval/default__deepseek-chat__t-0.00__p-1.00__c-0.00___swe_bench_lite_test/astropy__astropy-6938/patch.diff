diff --git a/astropy/io/fits/fitsrec.py b/astropy/io/fits/fitsrec.py
index 574b4073b1..8890e158e2 100644
--- a/astropy/io/fits/fitsrec.py
+++ b/astropy/io/fits/fitsrec.py
@@ -1261,7 +1261,7 @@ class FITS_rec(np.recarray):
 
         # Replace exponent separator in floating point numbers
         if 'D' in format:
-            output_field.replace(encode_ascii('E'), encode_ascii('D'))
+            output_field[:] = output_field.replace(encode_ascii('E'), encode_ascii('D'))
 
 
 def _get_recarray_field(array, key):
diff --git a/test_chararray_inplace.py b/test_chararray_inplace.py
new file mode 100644
index 0000000000..0030e8a29d
--- /dev/null
+++ b/test_chararray_inplace.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python
+"""Test script to find in-place modification methods for chararray"""
+
+import numpy as np
+from numpy import char as chararray
+
+# Create a test chararray
+arr = chararray.chararray((3,), itemsize=10)
+arr[0] = b'1.23E+05'
+arr[1] = b'4.56E-03'
+arr[2] = b'7.89E+10'
+
+print("Original array:")
+print(repr(arr))
+
+# Try different approaches for in-place modification
+
+# Approach 1: Use slice assignment with replace result
+print("\nApproach 1: Slice assignment")
+arr[:] = arr.replace(b'E', b'D')
+print(repr(arr))
+
+# Reset array
+arr[0] = b'1.23E+05'
+arr[1] = b'4.56E-03'
+arr[2] = b'7.89E+10'
+
+# Approach 2: Iterate and modify each element
+print("\nApproach 2: Iterative modification")
+for i in range(len(arr)):
+    arr[i] = arr[i].replace(b'E', b'D')
+print(repr(arr))
+
+# Reset array
+arr[0] = b'1.23E+05'
+arr[1] = b'4.56E-03'
+arr[2] = b'7.89E+10'
+
+# Approach 3: Use numpy.char.replace directly
+print("\nApproach 3: numpy.char.replace")
+result = np.char.replace(arr, b'E', b'D')
+print("Result:", repr(result))
+print("Original unchanged:", repr(arr))
+
+# Check if we can modify in-place with numpy.char.replace
+# (it doesn't have an out parameter)
\ No newline at end of file
diff --git a/test_chararray_replace.py b/test_chararray_replace.py
new file mode 100644
index 0000000000..6ec9a83068
--- /dev/null
+++ b/test_chararray_replace.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python
+"""Test script to verify chararray.replace behavior"""
+
+import numpy as np
+from numpy import char as chararray
+
+# Create a test chararray
+arr = chararray.chararray((3,), itemsize=10)
+arr[0] = b'1.23E+05'
+arr[1] = b'4.56E-03'
+arr[2] = b'7.89E+10'
+
+print("Original array:")
+print(repr(arr))
+print("Values:", [str(x) for x in arr])
+
+# Test the replace method
+result = arr.replace(b'E', b'D')
+
+print("\nAfter replace(b'E', b'D'):")
+print("Original array (unchanged):")
+print(repr(arr))
+print("Values:", [str(x) for x in arr])
+
+print("\nResult of replace (new array):")
+print(repr(result))
+print("Values:", [str(x) for x in result])
+
+# Test if we need to assign back
+arr = arr.replace(b'E', b'D')
+print("\nAfter assigning back to arr:")
+print(repr(arr))
+print("Values:", [str(x) for x in arr])
\ No newline at end of file
diff --git a/test_debug_fix.py b/test_debug_fix.py
new file mode 100644
index 0000000000..ff0ee3d3d9
--- /dev/null
+++ b/test_debug_fix.py
@@ -0,0 +1,57 @@
+#!/usr/bin/env python
+"""Debug script to check if our fix is being executed"""
+
+import numpy as np
+from astropy.io import fits
+from astropy.io.fits.column import Column
+
+# Monkey patch to add debug output
+original_scale_back_ascii = fits.fitsrec.FITS_rec._scale_back_ascii
+
+def debug_scale_back_ascii(self, col_idx, input_field, output_field):
+    print(f"DEBUG: _scale_back_ascii called with col_idx={col_idx}, format={self._coldefs[col_idx].format}")
+    print(f"DEBUG: input_field dtype: {input_field.dtype}, output_field dtype: {output_field.dtype}")
+    print(f"DEBUG: Before replace - first element: {output_field[0] if len(output_field) > 0 else 'empty'}")
+    
+    # Call the original method
+    result = original_scale_back_ascii(self, col_idx, input_field, output_field)
+    
+    print(f"DEBUG: After replace - first element: {output_field[0] if len(output_field) > 0 else 'empty'}")
+    return result
+
+fits.fitsrec.FITS_rec._scale_back_ascii = debug_scale_back_ascii
+
+# Create an ASCII table with D-format floating point numbers
+col1 = Column(name='col1', format='D10.3', array=[1.23e5, 4.56e-3, 7.89e10])
+col2 = Column(name='col2', format='D12.5', array=[1.23456e-5, 9.87654e10, 1.11111e-2])
+
+# Create the ASCII table
+table = fits.TableHDU.from_columns([col1, col2])
+
+# Write to file to trigger _scale_back_ascii
+import tempfile
+import os
+
+with tempfile.NamedTemporaryFile(suffix='.fits', delete=False) as f:
+    temp_filename = f.name
+
+try:
+    table.writeto(temp_filename, overwrite=True)
+    
+    # Read it back
+    with fits.open(temp_filename) as hdul:
+        hdu = hdul[1]
+        
+        # Check the actual file content
+        print("\nFile content (data section):")
+        with open(temp_filename, 'rb') as f:
+            content = f.read()
+            # Find the data section (after END keyword)
+            end_pos = content.find(b'END' + b' ' * 77)
+            if end_pos != -1:
+                data_section = content[end_pos + 80:]  # Skip END and padding
+                print(data_section.decode('ascii', errors='replace'))
+                    
+finally:
+    if os.path.exists(temp_filename):
+        os.unlink(temp_filename)
\ No newline at end of file
diff --git a/test_fits_ascii_bug.py b/test_fits_ascii_bug.py
new file mode 100644
index 0000000000..57e1ab675f
--- /dev/null
+++ b/test_fits_ascii_bug.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python
+"""Test script to reproduce the FITS D exponent bug in ASCII tables"""
+
+import numpy as np
+from astropy.io import fits
+from astropy.io.fits.column import Column
+
+# Create an ASCII table with D-format floating point numbers
+# D format in FITS means double precision with D exponent separator
+
+# Create columns with D format for ASCII table
+col1 = Column(name='col1', format='D10.3', array=[1.23e5, 4.56e-3, 7.89e10])
+col2 = Column(name='col2', format='D12.5', array=[1.23456e-5, 9.87654e10, 1.11111e-2])
+
+# Create the ASCII table
+table = fits.TableHDU.from_columns([col1, col2])
+
+# Print the raw data to see if D exponents are properly handled
+print("Raw data from ASCII table:")
+print(table.data)
+
+# Let's also check what happens when we write and read back the table
+import tempfile
+import os
+
+with tempfile.NamedTemporaryFile(suffix='.fits', delete=False) as f:
+    temp_filename = f.name
+
+try:
+    # Write the table to a temporary file
+    table.writeto(temp_filename, overwrite=True)
+    
+    # Read it back
+    with fits.open(temp_filename) as hdul:
+        hdu = hdul[1]  # The table HDU
+        print("\nData after writing and reading back:")
+        print(hdu.data)
+        
+        # Check the raw data representation
+        print("\nRaw data representation:")
+        for i, row in enumerate(hdu.data):
+            print(f"Row {i}: {row}")
+            
+        # Let's also examine the actual file content to see the exponent format
+        print("\nFile content (first few lines):")
+        with open(temp_filename, 'rb') as f:
+            for i, line in enumerate(f):
+                if i < 10:  # Show first 10 lines
+                    print(line.decode('ascii', errors='replace').rstrip())
+                else:
+                    break
+                    
+finally:
+    # Clean up
+    if os.path.exists(temp_filename):
+        os.unlink(temp_filename)
\ No newline at end of file
diff --git a/test_fits_bug.py b/test_fits_bug.py
new file mode 100644
index 0000000000..2a31a91388
--- /dev/null
+++ b/test_fits_bug.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python
+"""Test script to reproduce the FITS D exponent bug"""
+
+import numpy as np
+from astropy.io import fits
+from astropy.io.fits.column import Column
+
+# Create a simple ASCII table with D-format floating point numbers
+# D format in FITS means double precision with D exponent separator
+
+# Create columns with D format
+col1 = Column(name='col1', format='D10.3', array=[1.23e5, 4.56e-3, 7.89e10])
+col2 = Column(name='col2', format='D12.5', array=[1.23456e-5, 9.87654e10, 1.11111e-2])
+
+# Create the table
+table = fits.BinTableHDU.from_columns([col1, col2])
+
+# Print the raw data to see if D exponents are properly handled
+print("Raw data from table:")
+print(table.data)
+
+# Let's also check what happens when we write and read back the table
+import tempfile
+import os
+
+with tempfile.NamedTemporaryFile(suffix='.fits', delete=False) as f:
+    temp_filename = f.name
+
+try:
+    # Write the table to a temporary file
+    table.writeto(temp_filename, overwrite=True)
+    
+    # Read it back
+    with fits.open(temp_filename) as hdul:
+        hdu = hdul[1]  # The table HDU
+        print("\nData after writing and reading back:")
+        print(hdu.data)
+        
+        # Check the raw data representation
+        print("\nRaw data representation:")
+        for i, row in enumerate(hdu.data):
+            print(f"Row {i}: {row}")
+            
+finally:
+    # Clean up
+    if os.path.exists(temp_filename):
+        os.unlink(temp_filename)
\ No newline at end of file
