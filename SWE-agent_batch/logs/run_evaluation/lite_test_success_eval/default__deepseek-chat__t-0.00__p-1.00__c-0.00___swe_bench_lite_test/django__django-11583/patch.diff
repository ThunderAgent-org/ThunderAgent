diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py
index 25c3b44250..151f9f595b 100644
--- a/django/utils/autoreload.py
+++ b/django/utils/autoreload.py
@@ -139,9 +139,11 @@ def iter_modules_and_files(modules, extra_files):
         path = Path(filename)
         try:
             resolved_path = path.resolve(strict=True).absolute()
-        except FileNotFoundError:
+        except (FileNotFoundError, ValueError):
             # The module could have been removed, don't fail loudly if this
-            # is the case.
+            # is the case. Also handle ValueError which can occur when the path
+            # contains a null byte, which can happen intermittently on some
+            # filesystems or due to filesystem issues.
             continue
         results.add(resolved_path)
     return frozenset(results)
@@ -187,7 +189,10 @@ def sys_path_directories():
         path = Path(path)
         try:
             resolved_path = path.resolve(strict=True).absolute()
-        except FileNotFoundError:
+        except (FileNotFoundError, ValueError):
+            # Also handle ValueError which can occur when the path contains a
+            # null byte, which can happen intermittently on some filesystems
+            # or due to filesystem issues.
             continue
         # If the path is a file (like a zip file), watch the parent directory.
         if resolved_path.is_file():
@@ -359,8 +364,11 @@ class StatReloader(BaseReloader):
                 continue
             try:
                 mtime = file.stat().st_mtime
-            except OSError:
+            except (OSError, ValueError):
                 # This is thrown when the file does not exist.
+                # Also handle ValueError which can occur when the path contains a
+                # null byte, which can happen intermittently on some filesystems
+                # or due to filesystem issues.
                 continue
             seen_files.add(file)
             yield file, mtime
diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..64e14e95c4
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python3
+"""Script to reproduce the ValueError: embedded null byte issue"""
+
+import sys
+import os
+from pathlib import Path
+
+def test_path_resolve_with_null_byte():
+    """Test that demonstrates the ValueError when resolving a path with null byte"""
+    
+    # Create a path with an embedded null byte
+    # This simulates what might happen if a module path somehow contains a null byte
+    test_path = Path('/testbed\x00django/utils/autoreload.py')
+    
+    print(f"Testing path: {repr(str(test_path))}")
+    
+    try:
+        resolved_path = test_path.resolve(strict=True)
+        print(f"Resolved path: {resolved_path}")
+    except ValueError as e:
+        print(f"ValueError caught: {e}")
+        return True
+    except FileNotFoundError as e:
+        print(f"FileNotFoundError caught: {e}")
+        return False
+    except Exception as e:
+        print(f"Other exception caught: {type(e).__name__}: {e}")
+        return False
+    
+    return False
+
+def test_current_autoreload_behavior():
+    """Test the current iter_modules_and_files function behavior"""
+    from django.utils.autoreload import iter_modules_and_files
+    from types import ModuleType
+    import types
+    
+    # Create a mock module with a path containing null byte that would be processed
+    # We need to create a module that has __spec__ set with has_location=True
+    class MockSpec:
+        def __init__(self, origin):
+            self.origin = origin
+            self.has_location = True
+            self.loader = None
+    
+    class MockModule(ModuleType):
+        def __init__(self, name, file_path):
+            super().__init__(name)
+            self.__spec__ = MockSpec(file_path)
+    
+    # Test with a path containing null byte
+    module_with_null_byte = MockModule('test_module', '/testbed\x00django/utils/autoreload.py')
+    
+    print("\nTesting current iter_modules_and_files function:")
+    try:
+        result = iter_modules_and_files((module_with_null_byte,), frozenset())
+        print("No error occurred")
+        return False
+    except ValueError as e:
+        print(f"ValueError caught: {e}")
+        return True
+    except Exception as e:
+        print(f"Other exception caught: {type(e).__name__}: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+if __name__ == "__main__":
+    print("=== Testing path.resolve() with null byte ===")
+    error_occurred = test_path_resolve_with_null_byte()
+    
+    print("\n=== Testing current autoreload behavior ===")
+    error_occurred_autoreload = test_current_autoreload_behavior()
+    
+    if error_occurred or error_occurred_autoreload:
+        print("\n✓ Successfully reproduced the ValueError: embedded null byte issue")
+        sys.exit(0)
+    else:
+        print("\n✗ Could not reproduce the issue")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..adacd2b647
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,90 @@
+#!/usr/bin/env python3
+"""Test script to verify the fix for ValueError: embedded null byte"""
+
+import sys
+from django.utils.autoreload import iter_modules_and_files
+from types import ModuleType
+
+def test_fixed_autoreload_behavior():
+    """Test that the fixed iter_modules_and_files function handles null bytes gracefully"""
+    
+    # Create a mock module with a path containing null byte that would be processed
+    class MockSpec:
+        def __init__(self, origin):
+            self.origin = origin
+            self.has_location = True
+            self.loader = None
+    
+    class MockModule(ModuleType):
+        def __init__(self, name, file_path):
+            super().__init__(name)
+            self.__spec__ = MockSpec(file_path)
+    
+    # Test with a path containing null byte
+    module_with_null_byte = MockModule('test_module', '/testbed\x00django/utils/autoreload.py')
+    
+    print("Testing fixed iter_modules_and_files function with null byte path:")
+    try:
+        result = iter_modules_and_files((module_with_null_byte,), frozenset())
+        print("✓ No error occurred - fix is working!")
+        print(f"Result set contains {len(result)} paths")
+        return True
+    except ValueError as e:
+        print(f"✗ ValueError still occurs: {e}")
+        return False
+    except Exception as e:
+        print(f"✗ Other exception caught: {type(e).__name__}: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+def test_normal_autoreload_behavior():
+    """Test that the fixed function still works normally with valid paths"""
+    
+    # Test with a normal path
+    class MockSpec:
+        def __init__(self, origin):
+            self.origin = origin
+            self.has_location = True
+            self.loader = None
+    
+    class MockModule(ModuleType):
+        def __init__(self, name, file_path):
+            super().__init__(name)
+            self.__spec__ = MockSpec(file_path)
+    
+    # Test with a normal path
+    module_normal = MockModule('test_module', '/testbed/django/utils/autoreload.py')
+    
+    print("\nTesting fixed iter_modules_and_files function with normal path:")
+    try:
+        result = iter_modules_and_files((module_normal,), frozenset())
+        print("✓ Normal path processed successfully")
+        print(f"Result set contains {len(result)} paths")
+        # The path should be in the result set
+        from pathlib import Path
+        expected_path = Path('/testbed/django/utils/autoreload.py').resolve().absolute()
+        if expected_path in result:
+            print("✓ Expected path found in result set")
+            return True
+        else:
+            print("✗ Expected path not found in result set")
+            return False
+    except Exception as e:
+        print(f"✗ Exception caught: {type(e).__name__}: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+if __name__ == "__main__":
+    print("=== Testing the fix for ValueError: embedded null byte ===\n")
+    
+    test1_passed = test_fixed_autoreload_behavior()
+    test2_passed = test_normal_autoreload_behavior()
+    
+    if test1_passed and test2_passed:
+        print("\n✓ All tests passed! The fix is working correctly.")
+        sys.exit(0)
+    else:
+        print("\n✗ Some tests failed!")
+        sys.exit(1)
\ No newline at end of file
