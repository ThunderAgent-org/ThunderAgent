{"model_name_or_path": "vllm_local__--data--models--GLM-4.5-FP8__t-0.00__p-1.00__c-0.00___swe_bench_lite_test__bs32", "instance_id": "django__django-14997", "model_patch": "diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..7e5165ada5 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -4,12 +4,32 @@ from decimal import Decimal\n from django.apps.registry import Apps\n from django.db import NotSupportedError\n from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n-from django.db.backends.ddl_references import Statement\n+from django.db.backends.ddl_references import Expressions, IndexName, Statement, Table\n from django.db.backends.utils import strip_quotes\n from django.db.models import UniqueConstraint\n from django.db.transaction import atomic\n \n \n+class SQLiteExpressions(Expressions):\n+    \"\"\"\n+    SQLite-specific version of Expressions that generates unqualified column names\n+    for index expressions, since SQLite doesn't allow the \".\" operator in index expressions.\n+    \"\"\"\n+    def __str__(self):\n+        sql, params = self.compiler.compile(self.expressions)\n+        params = map(self.quote_value, params)\n+        \n+        # For SQLite, replace table-qualified column names with unqualified ones\n+        # in index expressions to avoid \"the '.' operator prohibited in index expressions\" error\n+        import re\n+        # Pattern to match quoted table names followed by quoted column names: \"table_name\".\"column_name\"\n+        pattern = r'\"([^\"]+)\"\\.\"([^\"]+)\"'\n+        # Replace with just the column name: \"column_name\"\n+        sql = re.sub(pattern, r'\"\\2\"', sql)\n+        \n+        return sql % tuple(params)\n+\n+\n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n     sql_delete_table = \"DROP TABLE %(table)s\"\n@@ -237,6 +257,28 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             ]\n \n         constraints = list(model._meta.constraints)\n+        \n+        # Store the original table name and capture existing unique indexes\n+        # This is needed to preserve constraints that were added via add_constraint\n+        original_table_name = model._meta.db_table\n+        existing_unique_indexes = []\n+        \n+        try:\n+            with self.connection.cursor() as cursor:\n+                # Get all unique indexes for the original table\n+                cursor.execute(\"\"\"\n+                    SELECT name, sql \n+                    FROM sqlite_master \n+                    WHERE type='index' \n+                    AND tbl_name = %s \n+                    AND sql LIKE 'CREATE UNIQUE INDEX%%'\n+                    AND name NOT LIKE 'sqlite_%%'\n+                \"\"\", [original_table_name])\n+                \n+                existing_unique_indexes = cursor.fetchall()\n+        except Exception:\n+            # If introspection fails, continue without preserving indexes\n+            pass\n \n         # Provide isolated instances of the fields to the new model body so\n         # that the existing model's internals aren't interfered with when\n@@ -298,6 +340,24 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n+        # Recreate unique indexes that existed on the original table\n+        # This preserves constraints that were added via add_constraint (e.g., in migrations)\n+        for index_name, index_sql in existing_unique_indexes:\n+            try:\n+                # The original SQL might reference the old table name, so we need to\n+                # update it to reference the new table name\n+                updated_index_sql = index_sql.replace(\n+                    f'ON \"{original_table_name}\"',\n+                    f'ON {self.quote_name(model._meta.db_table)}'\n+                )\n+                \n+                # Execute the updated index creation SQL\n+                self.execute(updated_index_sql)\n+            except Exception:\n+                # If recreating an index fails, continue with the rest\n+                # This ensures that a failure to recreate one index doesn't break the entire operation\n+                pass\n+\n         # Run deferred SQL on correct table\n         for sql in self.deferred_sql:\n             self.execute(sql)\n@@ -440,5 +500,56 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             self._remake_table(model)\n \n+    def _create_unique_sql(\n+        self, model, fields, name=None, condition=None, deferrable=None,\n+        include=None, opclasses=None, expressions=None,\n+    ):\n+        \"\"\"\n+        Override the base _create_unique_sql method to use SQLiteExpressions\n+        instead of Expressions for SQLite compatibility.\n+        \"\"\"\n+        if (\n+            (\n+                deferrable and\n+                not self.connection.features.supports_deferrable_unique_constraints\n+            ) or\n+            (condition and not self.connection.features.supports_partial_indexes) or\n+            (include and not self.connection.features.supports_covering_indexes) or\n+            (expressions and not self.connection.features.supports_expression_indexes)\n+        ):\n+            return None\n+\n+        def create_unique_name(*args, **kwargs):\n+            return self.quote_name(self._create_index_name(*args, **kwargs))\n+\n+        from django.db.models.sql import Query\n+        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n+        table = model._meta.db_table\n+        columns = [field.column for field in fields]\n+        if name is None:\n+            name = IndexName(table, columns, '_uniq', create_unique_name)\n+        else:\n+            name = self.quote_name(name)\n+        if condition or include or opclasses or expressions:\n+            sql = self.sql_create_unique_index\n+        else:\n+            sql = self.sql_create_unique\n+        if columns:\n+            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n+        elif expressions:\n+            # Use SQLiteExpressions instead of Expressions for SQLite compatibility\n+            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n+        else:\n+            columns = Expressions(table, expressions, compiler, self.quote_value)\n+        return Statement(\n+            sql,\n+            table=Table(table, self.quote_name),\n+            name=name,\n+            columns=columns,\n+            condition=self._index_condition_sql(condition),\n+            deferrable=self._deferrable_constraint_sql(deferrable),\n+            include=self._index_include_sql(model, include),\n+        )\n+\n     def _collate_sql(self, collation):\n         return 'COLLATE ' + collation\n"}