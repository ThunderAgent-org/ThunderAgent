diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py
index e19c881cda..072a2efc14 100644
--- a/django/db/migrations/serializer.py
+++ b/django/db/migrations/serializer.py
@@ -273,7 +273,7 @@ class TupleSerializer(BaseSequenceSerializer):
 class TypeSerializer(BaseSerializer):
     def serialize(self):
         special_cases = [
-            (models.Model, "models.Model", []),
+            (models.Model, "models.Model", ["from django.db import models"]),
             (type(None), 'type(None)', []),
         ]
         for case, string, imports in special_cases:
diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py
index a590ff4398..6eccca19c5 100644
--- a/tests/migrations/test_writer.py
+++ b/tests/migrations/test_writer.py
@@ -787,6 +787,27 @@ class WriterTests(SimpleTestCase):
         output = writer.as_string()
         self.assertIn("from django.db import migrations\n", output)
 
+    def test_models_import_in_bases(self):
+        """
+        django.db.models should be imported when models.Model is used in bases.
+        """
+        migration = type("Migration", (migrations.Migration,), {
+            "operations": [
+                migrations.CreateModel(
+                    name='MyModel',
+                    fields=[],
+                    options={},
+                    bases=('test_app.models.MyMixin', models.Model),
+                ),
+            ]
+        })
+        writer = MigrationWriter(migration)
+        output = writer.as_string()
+        # Ensure that both migrations and models are imported
+        self.assertIn("from django.db import migrations, models\n", output)
+        # Ensure the generated migration can be executed without errors
+        result = self.safe_exec(output)
+
     def test_deconstruct_class_arguments(self):
         # Yes, it doesn't make sense to use a class as a default for a
         # CharField. It does make sense for custom fields though, for example
