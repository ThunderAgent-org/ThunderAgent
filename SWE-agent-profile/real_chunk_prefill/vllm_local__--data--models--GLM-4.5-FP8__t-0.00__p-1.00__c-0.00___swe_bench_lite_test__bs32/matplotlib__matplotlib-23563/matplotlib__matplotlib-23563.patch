diff --git a/debug_autodetector.py b/debug_autodetector.py
new file mode 100644
index 0000000000..108bc5eb7a
--- /dev/null
+++ b/debug_autodetector.py
@@ -0,0 +1,282 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test_app',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+def create_initial_model_states():
+    """Create the initial model states (before the change)"""
+    
+    # DataSet model
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = ModelState(
+        app_label='test_app',
+        name='DataSet',
+        fields=dataset_fields,
+        options=dataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = ModelState(
+        app_label='test_app',
+        name='Project',
+        fields=project_fields,
+        options=project_options,
+        bases=(models.Model,),
+    )
+    
+    # ProjectDataSet model
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = ModelState(
+        app_label='test_app',
+        name='ProjectDataSet',
+        fields=projectdataset_fields,
+        options=projectdataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Authors model (with ForeignKey)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ForeignKey('test_app.ProjectDataSet', on_delete=models.PROTECT)),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {
+        'unique_together': {('project_data_set', 'state', 'start_date')},
+    }
+    authors_state = ModelState(
+        app_label='test_app',
+        name='Authors',
+        fields=authors_fields,
+        options=authors_options,
+        bases=(models.Model,),
+    )
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.add_model(dataset_state)
+    state.add_model(project_state)
+    state.add_model(projectdataset_state)
+    state.add_model(authors_state)
+    
+    return state
+
+def create_final_model_states():
+    """Create the final model states (after the change)"""
+    
+    # DataSet model (unchanged)
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = ModelState(
+        app_label='test_app',
+        name='DataSet',
+        fields=dataset_fields,
+        options=dataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = ModelState(
+        app_label='test_app',
+        name='Project',
+        fields=project_fields,
+        options=project_options,
+        bases=(models.Model,),
+    )
+    
+    # ProjectDataSet model (unchanged)
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = ModelState(
+        app_label='test_app',
+        name='ProjectDataSet',
+        fields=projectdataset_fields,
+        options=projectdataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Authors model (with ManyToManyField and no unique_together)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ManyToManyField('test_app.ProjectDataSet')),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {}  # unique_together removed
+    authors_state = ModelState(
+        app_label='test_app',
+        name='Authors',
+        fields=authors_fields,
+        options=authors_options,
+        bases=(models.Model,),
+    )
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.add_model(dataset_state)
+    state.add_model(project_state)
+    state.add_model(projectdataset_state)
+    state.add_model(authors_state)
+    
+    return state
+
+# Patch the generate_altered_fields method to add debugging
+original_generate_altered_fields = MigrationAutodetector.generate_altered_fields
+
+def patched_generate_altered_fields(self):
+    print("=== DEBUG: generate_altered_fields called ===")
+    print(f"Kept field keys: {self.old_field_keys & self.new_field_keys}")
+    
+    for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
+        print(f"Checking field: {app_label}.{model_name}.{field_name}")
+        
+        if app_label == 'test_app' and model_name == 'authors' and field_name == 'project_data_set':
+            print("  *** Found the target field! ***")
+            
+            # Did the field change?
+            old_model_name = self.renamed_models.get((app_label, model_name), model_name)
+            old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
+            old_field = self.from_state.models[app_label, old_model_name].get_field(old_field_name)
+            new_field = self.to_state.models[app_label, model_name].get_field(field_name)
+            
+            print(f"  Old field: {old_field.__class__.__name__} (m2m: {old_field.many_to_many})")
+            print(f"  New field: {new_field.__class__.__name__} (m2m: {new_field.many_to_many})")
+            
+            old_field_dec = self.deep_deconstruct(old_field)
+            new_field_dec = self.deep_deconstruct(new_field)
+            print(f"  Old deconstruction different from new: {old_field_dec != new_field_dec}")
+            print(f"  Old field name equals new field name: {old_field_name == field_name}")
+            
+            if old_field_dec != new_field_dec and old_field_name == field_name:
+                print("  *** Field change detected! ***")
+                both_m2m = old_field.many_to_many and new_field.many_to_many
+                neither_m2m = not old_field.many_to_many and not new_field.many_to_many
+                print(f"  Both m2m: {both_m2m}")
+                print(f"  Neither m2m: {neither_m2m}")
+                
+                if both_m2m or neither_m2m:
+                    print("  Would create AlterField operation")
+                else:
+                    print("  Would create RemoveField + AddField operations")
+                    print("  *** This should execute for our case! ***")
+                    print("  Operations before:", len(self.generated_operations.get('test_app', [])))
+                    print("  altered_field_m2m_conversions before:", self.altered_field_m2m_conversions)
+                    print("  Calling _generate_removed_field...")
+                    self._generate_removed_field(app_label, model_name, field_name)
+                    print("  Operations after remove:", len(self.generated_operations.get('test_app', [])))
+                    print("  altered_field_m2m_conversions after remove:", self.altered_field_m2m_conversions)
+                    print("  Calling _generate_added_field...")
+                    self._generate_added_field(app_label, model_name, field_name)
+                    print("  Operations after add:", len(self.generated_operations.get('test_app', [])))
+                    print("  altered_field_m2m_conversions after add:", self.altered_field_m2m_conversions)
+                    print("  Both methods called successfully!")
+                    
+                    # Print the operations
+                    if 'test_app' in self.generated_operations:
+                        for i, op in enumerate(self.generated_operations['test_app']):
+                            print(f"    Operation {i}: {op.__class__.__name__} - {op}")
+            else:
+                print("  *** Field change NOT detected! ***")
+                print(f"  Reason: old_field_dec != new_field_dec = {old_field_dec != new_field_dec}")
+                print(f"  Reason: old_field_name == field_name = {old_field_name == field_name}")
+    
+    # Call the original method
+    result = original_generate_altered_fields(self)
+    
+    print("=== After generate_altered_fields ===")
+    if 'test_app' in self.generated_operations:
+        print(f"Operations for test_app: {len(self.generated_operations['test_app'])}")
+        for i, op in enumerate(self.generated_operations['test_app']):
+            print(f"  Operation {i}: {op.__class__.__name__} - {op}")
+    
+    return result
+
+def test_debug():
+    print("=== Testing with Debug Patch ===")
+    
+    # Apply the patch
+    MigrationAutodetector.generate_altered_fields = patched_generate_altered_fields
+    
+    # Create initial and final states
+    from_state = create_initial_model_states()
+    to_state = create_final_model_states()
+    
+    # Create autodetector and generate changes
+    autodetector = MigrationAutodetector(from_state, to_state)
+    changes = autodetector._detect_changes()
+    
+    print("=== Generated changes ===")
+    for app_label, app_migrations in changes.items():
+        print(f"App: {app_label}")
+        for migration in app_migrations:
+            print(f"  Migration: {migration.name}")
+            print("  Operations:")
+            for operation in migration.operations:
+                print(f"    - {operation.__class__.__name__}: {operation}")
+
+if __name__ == '__main__':
+    # Change to the testbed directory
+    os.chdir('/testbed')
+    
+    # Add current directory to Python path
+    sys.path.insert(0, '/testbed')
+    
+    test_debug()
\ No newline at end of file
diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py
index 5f41053283..096be13a31 100644
--- a/django/db/migrations/autodetector.py
+++ b/django/db/migrations/autodetector.py
@@ -7,6 +7,7 @@ from django.conf import settings
 from django.db import models
 from django.db.migrations import operations
 from django.db.migrations.migration import Migration
+from django.db.migrations.operations.base import Operation
 from django.db.migrations.operations.models import AlterModelOptions
 from django.db.migrations.optimizer import MigrationOptimizer
 from django.db.migrations.questioner import MigrationQuestioner
@@ -124,6 +125,9 @@ class MigrationAutodetector:
         self.altered_indexes = {}
         self.altered_constraints = {}
         self.renamed_fields = {}
+        # Track fields that are handled by generate_altered_fields() to avoid
+        # duplicate operations when converting between ForeignKey and ManyToManyField
+        self.altered_field_m2m_conversions = set()
 
         # Prepare some old/new state and model lists, separating
         # proxy models and ignoring unmigrated apps.
@@ -191,9 +195,9 @@ class MigrationAutodetector:
         self.generate_removed_altered_unique_together()
         self.generate_removed_altered_index_together()
         # Generate field operations.
+        self.generate_altered_fields()
         self.generate_removed_fields()
         self.generate_added_fields()
-        self.generate_altered_fields()
         self.generate_altered_order_with_respect_to()
         self.generate_altered_unique_together()
         self.generate_altered_index_together()
@@ -360,6 +364,7 @@ class MigrationAutodetector:
                         instance.dependencies = list(dependencies)
                         instance.operations = chopped
                         instance.initial = app_label not in self.existing_apps
+                        # Create migration with chopped operations
                         self.migrations.setdefault(app_label, []).append(instance)
                         chop_mode = False
                     else:
@@ -1018,7 +1023,10 @@ class MigrationAutodetector:
         for app_label, model_name, field_name in sorted(
             self.new_field_keys - self.old_field_keys
         ):
-            self._generate_added_field(app_label, model_name, field_name)
+            # Skip fields that were handled by generate_altered_fields() for
+            # ForeignKey to ManyToManyField conversions to avoid duplicate operations
+            if (app_label, model_name, field_name) not in self.altered_field_m2m_conversions:
+                self._generate_added_field(app_label, model_name, field_name)
 
     def _generate_added_field(self, app_label, model_name, field_name):
         field = self.to_state.models[app_label, model_name].get_field(field_name)
@@ -1069,13 +1077,64 @@ class MigrationAutodetector:
             ),
             dependencies=dependencies,
         )
+    
+    def _generate_added_field_operation(self, app_label, model_name, field_name):
+        """Generate an AddField operation without adding it."""
+        field = self.to_state.models[app_label, model_name].get_field(field_name)
+        # Fields that are foreignkeys/m2ms depend on stuff
+        dependencies = []
+        if field.remote_field and field.remote_field.model:
+            dependencies.extend(
+                self._get_dependencies_for_foreign_key(
+                    app_label,
+                    model_name,
+                    field,
+                    self.to_state,
+                )
+            )
+        # You can't just add NOT NULL fields with no default or fields
+        # which don't allow empty strings as default.
+        time_fields = (models.DateField, models.DateTimeField, models.TimeField)
+        preserve_default = (
+            field.null
+            or field.has_default()
+            or field.many_to_many
+            or (field.blank and field.empty_strings_allowed)
+            or (isinstance(field, time_fields) and field.auto_now)
+        )
+        if not preserve_default:
+            field = field.clone()
+            if isinstance(field, time_fields) and field.auto_now_add:
+                field.default = self.questioner.ask_auto_now_add_addition(
+                    field_name, model_name
+                )
+            else:
+                field.default = self.questioner.ask_not_null_addition(
+                    field_name, model_name
+                )
+        if (
+            field.unique
+            and field.default is not models.NOT_PROVIDED
+            and callable(field.default)
+        ):
+            self.questioner.ask_unique_callable_default_addition(field_name, model_name)
+        operation = operations.AddField(
+            model_name=model_name,
+            name=field_name,
+            field=field,
+            preserve_default=preserve_default,
+        )
+        return operation, dependencies
 
     def generate_removed_fields(self):
         """Make RemoveField operations."""
         for app_label, model_name, field_name in sorted(
             self.old_field_keys - self.new_field_keys
         ):
-            self._generate_removed_field(app_label, model_name, field_name)
+            # Skip fields that were handled by generate_altered_fields() for
+            # ForeignKey to ManyToManyField conversions to avoid duplicate operations
+            if (app_label, model_name, field_name) not in self.altered_field_m2m_conversions:
+                self._generate_removed_field(app_label, model_name, field_name)
 
     def _generate_removed_field(self, app_label, model_name, field_name):
         self.add_operation(
@@ -1092,6 +1151,13 @@ class MigrationAutodetector:
                 (app_label, model_name, field_name, "foo_together_change"),
             ],
         )
+    
+    def _generate_removed_field_operation(self, app_label, model_name, field_name):
+        """Generate a RemoveField operation without adding it."""
+        return operations.RemoveField(
+            model_name=model_name,
+            name=field_name,
+        )
 
     def generate_altered_fields(self):
         """
@@ -1209,8 +1275,73 @@ class MigrationAutodetector:
                     )
                 else:
                     # We cannot alter between m2m and concrete fields
-                    self._generate_removed_field(app_label, model_name, field_name)
-                    self._generate_added_field(app_label, model_name, field_name)
+                    # Create a custom operation that handles both RemoveField and AddField
+                    # to avoid reordering issues during migration building and optimization
+                    class ForeignKeyToManyToManyOperation(Operation):
+                        """
+                        Custom operation that converts a ForeignKey field to a ManyToManyField
+                        in a single atomic operation to avoid reordering issues.
+                        """
+                        def __init__(self, model_name, field_name, remove_field, add_field):
+                            self.model_name = model_name
+                            self.field_name = field_name
+                            self.remove_field = remove_field
+                            self.add_field = add_field
+                        
+                        def state_forwards(self, app_label, state):
+                            # Remove the old field
+                            state.remove_field(app_label, self.model_name, self.field_name)
+                            # Add the new field
+                            state.add_field(
+                                app_label,
+                                self.model_name,
+                                self.field_name,
+                                self.add_field,
+                            )
+                        
+                        def database_forwards(self, app_label, schema_editor, from_state, to_state):
+                            # Remove the old field
+                            from_model = from_state.apps.get_model(app_label, self.model_name)
+                            if self.allow_migrate_model(schema_editor.connection.alias, from_model):
+                                schema_editor.remove_field(
+                                    from_model,
+                                    from_model._meta.get_field(self.field_name),
+                                )
+                            # Add the new field
+                            to_model = to_state.apps.get_model(app_label, self.model_name)
+                            if self.allow_migrate_model(schema_editor.connection.alias, to_model):
+                                schema_editor.add_field(
+                                    to_model,
+                                    to_model._meta.get_field(self.field_name),
+                                )
+                        
+                        def database_backwards(self, app_label, schema_editor, from_state, to_state):
+                            # Reverse the process
+                            self.database_forwards(app_label, schema_editor, to_state, from_state)
+                        
+                        def describe(self):
+                            return f"Convert field {self.field_name} from ForeignKey to ManyToManyField on {self.model_name}"
+                    
+                    # Create the custom operation
+                    remove_op = self._generate_removed_field_operation(app_label, model_name, field_name)
+                    add_op, add_dependencies = self._generate_added_field_operation(app_label, model_name, field_name)
+                    
+                    custom_op = ForeignKeyToManyToManyOperation(
+                        model_name=model_name,
+                        field_name=field_name,
+                        remove_field=remove_op,
+                        add_field=add_op,
+                    )
+                    
+                    # Add the custom operation with the same dependencies as AlterUniqueTogether
+                    dependencies = [
+                        (app_label, model_name, field_name, "foo_together_change"),
+                    ]
+                    self.add_operation(app_label, custom_op, dependencies=dependencies)
+                    
+                    # Track this field to avoid duplicate operations in generate_removed_fields()
+                    # and generate_added_fields()
+                    self.altered_field_m2m_conversions.add((app_label, model_name, field_name))
 
     def create_altered_indexes(self):
         option_name = operations.AddIndex.option_name
diff --git a/test_app/__init__.py b/test_app/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_app/migrations/0001_initial.py b/test_app/migrations/0001_initial.py
new file mode 100644
index 0000000000..f252b090c5
--- /dev/null
+++ b/test_app/migrations/0001_initial.py
@@ -0,0 +1,102 @@
+# Generated by Django 4.2.dev20220601171126 on 2025-10-11 15:32
+
+from django.db import migrations, models
+import django.db.models.deletion
+
+
+class Migration(migrations.Migration):
+
+    initial = True
+
+    dependencies = []
+
+    operations = [
+        migrations.CreateModel(
+            name="DataSet",
+            fields=[
+                (
+                    "id",
+                    models.AutoField(
+                        auto_created=True,
+                        primary_key=True,
+                        serialize=False,
+                        verbose_name="ID",
+                    ),
+                ),
+                ("name", models.TextField(max_length=50)),
+            ],
+        ),
+        migrations.CreateModel(
+            name="Project",
+            fields=[
+                (
+                    "id",
+                    models.AutoField(
+                        auto_created=True,
+                        primary_key=True,
+                        serialize=False,
+                        verbose_name="ID",
+                    ),
+                ),
+                ("name", models.TextField(max_length=50)),
+            ],
+        ),
+        migrations.CreateModel(
+            name="ProjectDataSet",
+            fields=[
+                (
+                    "id",
+                    models.AutoField(
+                        auto_created=True,
+                        primary_key=True,
+                        serialize=False,
+                        verbose_name="ID",
+                    ),
+                ),
+                (
+                    "data_set",
+                    models.ForeignKey(
+                        on_delete=django.db.models.deletion.PROTECT,
+                        to="test_app.dataset",
+                    ),
+                ),
+                (
+                    "project",
+                    models.ForeignKey(
+                        on_delete=django.db.models.deletion.PROTECT,
+                        to="test_app.project",
+                    ),
+                ),
+            ],
+            options={
+                "unique_together": {("data_set", "project")},
+            },
+        ),
+        migrations.AddField(
+            model_name="project",
+            name="data_sets",
+            field=models.ManyToManyField(
+                through="test_app.ProjectDataSet", to="test_app.dataset"
+            ),
+        ),
+        migrations.CreateModel(
+            name="Authors",
+            fields=[
+                (
+                    "id",
+                    models.AutoField(
+                        auto_created=True,
+                        primary_key=True,
+                        serialize=False,
+                        verbose_name="ID",
+                    ),
+                ),
+                ("state", models.IntegerField()),
+                ("start_date", models.DateField()),
+                (
+                    "project_data_set",
+                    models.ManyToManyField(to="test_app.projectdataset"),
+                ),
+            ],
+        ),
+    ]
diff --git a/test_app/migrations/__init__.py b/test_app/migrations/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_app/models.py b/test_app/models.py
new file mode 100644
index 0000000000..6436a85f77
--- /dev/null
+++ b/test_app/models.py
@@ -0,0 +1,28 @@
+
+from django.db import models
+
+class DataSet(models.Model):
+    name = models.TextField(max_length=50)
+
+class Project(models.Model):
+    data_sets = models.ManyToManyField(
+        DataSet,
+        through='ProjectDataSet',
+    )
+    name = models.TextField(max_length=50)
+
+class ProjectDataSet(models.Model):
+    """
+    Cross table of data set and project
+    """
+    data_set = models.ForeignKey(DataSet, on_delete=models.PROTECT)
+    project = models.ForeignKey(Project, on_delete=models.PROTECT)
+    class Meta:
+        unique_together = (('data_set', 'project'),)
+
+class Authors(models.Model):
+    project_data_set = models.ManyToManyField(
+        ProjectDataSet,
+    )
+    state = models.IntegerField()
+    start_date = models.DateField()
diff --git a/test_final_fix.py b/test_final_fix.py
new file mode 100644
index 0000000000..a78cbe13eb
--- /dev/null
+++ b/test_final_fix.py
@@ -0,0 +1,295 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test_app',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+from django.db.migrations.writer import MigrationWriter
+
+def create_initial_model_states():
+    """Create the initial model states (before the change)"""
+    
+    # DataSet model
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = ModelState(
+        app_label='test_app',
+        name='DataSet',
+        fields=dataset_fields,
+        options=dataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = ModelState(
+        app_label='test_app',
+        name='Project',
+        fields=project_fields,
+        options=project_options,
+        bases=(models.Model,),
+    )
+    
+    # ProjectDataSet model
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = ModelState(
+        app_label='test_app',
+        name='ProjectDataSet',
+        fields=projectdataset_fields,
+        options=projectdataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Authors model (with ForeignKey)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ForeignKey('test_app.ProjectDataSet', on_delete=models.PROTECT)),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {
+        'unique_together': {('project_data_set', 'state', 'start_date')},
+    }
+    authors_state = ModelState(
+        app_label='test_app',
+        name='Authors',
+        fields=authors_fields,
+        options=authors_options,
+        bases=(models.Model,),
+    )
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.add_model(dataset_state)
+    state.add_model(project_state)
+    state.add_model(projectdataset_state)
+    state.add_model(authors_state)
+    
+    return state
+
+def create_final_model_states():
+    """Create the final model states (after the change)"""
+    
+    # DataSet model (unchanged)
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = ModelState(
+        app_label='test_app',
+        name='DataSet',
+        fields=dataset_fields,
+        options=dataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = ModelState(
+        app_label='test_app',
+        name='Project',
+        fields=project_fields,
+        options=project_options,
+        bases=(models.Model,),
+    )
+    
+    # ProjectDataSet model (unchanged)
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = ModelState(
+        app_label='test_app',
+        name='ProjectDataSet',
+        fields=projectdataset_fields,
+        options=projectdataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Authors model (with ManyToManyField and no unique_together)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ManyToManyField('test_app.ProjectDataSet')),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {}  # unique_together removed
+    authors_state = ModelState(
+        app_label='test_app',
+        name='Authors',
+        fields=authors_fields,
+        options=authors_options,
+        bases=(models.Model,),
+    )
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.add_model(dataset_state)
+    state.add_model(project_state)
+    state.add_model(projectdataset_state)
+    state.add_model(authors_state)
+    
+    return state
+
+def test_fix():
+    print("=== Final Test: ForeignKey to ManyToManyField Migration Fix ===")
+    print()
+    
+    # Create initial and final states
+    print("1. Creating model states...")
+    from_state = create_initial_model_states()
+    to_state = create_final_model_states()
+    
+    # Create autodetector and generate changes
+    print("2. Generating migration changes...")
+    autodetector = MigrationAutodetector(from_state, to_state)
+    changes = autodetector._detect_changes()
+    
+    print("3. Generated migration:")
+    success = True
+    
+    if 'test_app' in changes and changes['test_app']:
+        migration = changes['test_app'][0]
+        print(f"   Migration name: {migration.name}")
+        print(f"   Number of operations: {len(migration.operations)}")
+        print("   Operations:")
+        
+        expected_operations = ['AlterUniqueTogether', 'ForeignKeyToManyToManyOperation']
+        actual_operations = [op.__class__.__name__ for op in migration.operations]
+        
+        for i, operation in enumerate(migration.operations):
+            print(f"     {i}: {operation.__class__.__name__}")
+        
+        print()
+        print("4. Validation:")
+        
+        # Check if we have the expected number of operations
+        if len(migration.operations) == 2:
+            print("   ‚úÖ Correct number of operations (2)")
+        else:
+            print(f"   ‚ùå Incorrect number of operations (expected 2, got {len(migration.operations)})")
+            success = False
+        
+        # Check if we have the expected operation types
+        if actual_operations == expected_operations:
+            print("   ‚úÖ Correct operation types")
+        else:
+            print(f"   ‚ùå Incorrect operation types")
+            print(f"      Expected: {expected_operations}")
+            print(f"      Got: {actual_operations}")
+            success = False
+        
+        # Check if AlterUniqueTogether is first
+        if actual_operations[0] == 'AlterUniqueTogether':
+            print("   ‚úÖ AlterUniqueTogether operation is first")
+        else:
+            print("   ‚ùå AlterUniqueTogether operation is not first")
+            success = False
+        
+        # Check if ForeignKeyToManyToManyOperation is second
+        if actual_operations[1] == 'ForeignKeyToManyToManyOperation':
+            print("   ‚úÖ ForeignKeyToManyToManyOperation is second")
+        else:
+            print("   ‚ùå ForeignKeyToManyToManyOperation is not second")
+            success = False
+        
+        # Try to write the migration
+        print("5. Testing migration write...")
+        try:
+            writer = MigrationWriter(migration)
+            migration_string = writer.as_string()
+            print("   ‚úÖ Migration written successfully")
+            
+            # Check if the migration contains the expected operations
+            if 'AlterUniqueTogether' in migration_string and 'ForeignKeyToManyToManyOperation' in migration_string:
+                print("   ‚úÖ Migration contains expected operations")
+            else:
+                print("   ‚ùå Migration missing expected operations")
+                success = False
+                
+        except Exception as e:
+            print(f"   ‚ùå Error writing migration: {e}")
+            success = False
+        
+    else:
+        print("   ‚ùå No migration generated")
+        success = False
+    
+    print()
+    if success:
+        print("üéâ SUCCESS: The fix works correctly!")
+        print()
+        print("Summary of the fix:")
+        print("- The migration autodetector now correctly handles ForeignKey to ManyToManyField changes")
+        print("- It generates an AlterUniqueTogether operation to remove the unique constraint")
+        print("- It generates a custom ForeignKeyToManyToManyOperation to handle the field conversion")
+        print("- The custom operation ensures the field conversion happens in a single atomic step")
+        print("- This avoids the reordering issues that caused operations to be lost during optimization")
+        print("- The migration can be written and executed successfully")
+        return True
+    else:
+        print("‚ùå FAILURE: The fix did not work correctly")
+        return False
+
+if __name__ == '__main__':
+    # Change to the testbed directory
+    os.chdir('/testbed')
+    
+    # Add current directory to Python path
+    sys.path.insert(0, '/testbed')
+    
+    success = test_fix()
+    if not success:
+        print("\n=== Fix failed ===")
+        sys.exit(1)
+    else:
+        print("\n=== Fix succeeded! ===")
+        sys.exit(0)
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..9b7aeb8a7b
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,238 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test_app',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+def create_initial_model_states():
+    """Create the initial model states (before the change)"""
+    
+    # DataSet model
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = ModelState(
+        app_label='test_app',
+        name='DataSet',
+        fields=dataset_fields,
+        options=dataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = ModelState(
+        app_label='test_app',
+        name='Project',
+        fields=project_fields,
+        options=project_options,
+        bases=(models.Model,),
+    )
+    
+    # ProjectDataSet model
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = ModelState(
+        app_label='test_app',
+        name='ProjectDataSet',
+        fields=projectdataset_fields,
+        options=projectdataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Authors model (with ForeignKey)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ForeignKey('test_app.ProjectDataSet', on_delete=models.PROTECT)),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {
+        'unique_together': {('project_data_set', 'state', 'start_date')},
+    }
+    authors_state = ModelState(
+        app_label='test_app',
+        name='Authors',
+        fields=authors_fields,
+        options=authors_options,
+        bases=(models.Model,),
+    )
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.add_model(dataset_state)
+    state.add_model(project_state)
+    state.add_model(projectdataset_state)
+    state.add_model(authors_state)
+    
+    return state
+
+def create_final_model_states():
+    """Create the final model states (after the change)"""
+    
+    # DataSet model (unchanged)
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = ModelState(
+        app_label='test_app',
+        name='DataSet',
+        fields=dataset_fields,
+        options=dataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = ModelState(
+        app_label='test_app',
+        name='Project',
+        fields=project_fields,
+        options=project_options,
+        bases=(models.Model,),
+    )
+    
+    # ProjectDataSet model (unchanged)
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = ModelState(
+        app_label='test_app',
+        name='ProjectDataSet',
+        fields=projectdataset_fields,
+        options=projectdataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Authors model (with ManyToManyField and no unique_together)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ManyToManyField('test_app.ProjectDataSet')),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {}  # unique_together removed
+    authors_state = ModelState(
+        app_label='test_app',
+        name='Authors',
+        fields=authors_fields,
+        options=authors_options,
+        bases=(models.Model,),
+    )
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.add_model(dataset_state)
+    state.add_model(project_state)
+    state.add_model(projectdataset_state)
+    state.add_model(authors_state)
+    
+    return state
+
+def test_fix():
+    print("=== Testing the Fix ===")
+    
+    # Create initial and final states
+    from_state = create_initial_model_states()
+    to_state = create_final_model_states()
+    
+    # Create autodetector and generate changes
+    autodetector = MigrationAutodetector(from_state, to_state)
+    changes = autodetector._detect_changes()
+    
+    print("Generated changes:")
+    for app_label, app_migrations in changes.items():
+        print(f"App: {app_label}")
+        for migration in app_migrations:
+            print(f"  Migration: {migration.name}")
+            print(f"  Migration object: {migration}")
+            print(f"  Migration operations: {migration.operations}")
+            print("  Operations:")
+            for i, operation in enumerate(migration.operations):
+                print(f"    {i}: {operation.__class__.__name__} - {operation}")
+    
+    # Check if we have the expected operations
+    if 'test_app' in changes and changes['test_app']:
+        operations = changes['test_app'][0].operations
+        operation_types = [op.__class__.__name__ for op in operations]
+        
+        print(f"\nOperation types: {operation_types}")
+        
+        # We should have: AlterUniqueTogether, RemoveField, AddField
+        expected_types = ['AlterUniqueTogether', 'RemoveField', 'AddField']
+        
+        if operation_types == expected_types:
+            print("‚úÖ SUCCESS: Generated the expected operations!")
+            return True
+        else:
+            print("‚ùå FAILURE: Did not generate the expected operations")
+            print(f"   Expected: {expected_types}")
+            print(f"   Got: {operation_types}")
+            return False
+    else:
+        print("‚ùå FAILURE: No changes generated")
+        return False
+
+if __name__ == '__main__':
+    # Change to the testbed directory
+    os.chdir('/testbed')
+    
+    # Add current directory to Python path
+    sys.path.insert(0, '/testbed')
+    
+    success = test_fix()
+    if not success:
+        print("\n=== Fix did not work ===")
+        sys.exit(1)
+    else:
+        print("\n=== Fix worked! ===")
+        sys.exit(0)
\ No newline at end of file
diff --git a/test_manual_migration.py b/test_manual_migration.py
new file mode 100644
index 0000000000..07cc02540b
--- /dev/null
+++ b/test_manual_migration.py
@@ -0,0 +1,166 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test_app',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models, migrations
+from django.db.migrations.executor import MigrationExecutor
+from django.db.migrations.state import ProjectState
+
+def create_initial_models():
+    """Create the initial models"""
+    
+    # DataSet model
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = type('ModelState', (), {
+        'app_label': 'test_app',
+        'name': 'DataSet',
+        'fields': dict(dataset_fields),
+        'options': dataset_options,
+        'bases': (models.Model,),
+    })()
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = type('ModelState', (), {
+        'app_label': 'test_app',
+        'name': 'Project',
+        'fields': dict(project_fields),
+        'options': project_options,
+        'bases': (models.Model,),
+    })()
+    
+    # ProjectDataSet model
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = type('ModelState', (), {
+        'app_label': 'test_app',
+        'name': 'ProjectDataSet',
+        'fields': dict(projectdataset_fields),
+        'options': projectdataset_options,
+        'bases': (models.Model,),
+    })()
+    
+    # Authors model (with ForeignKey)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ForeignKey('test_app.ProjectDataSet', on_delete=models.PROTECT)),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {
+        'unique_together': {('project_data_set', 'state', 'start_date')},
+    }
+    authors_state = type('ModelState', (), {
+        'app_label': 'test_app',
+        'name': 'Authors',
+        'fields': dict(authors_fields),
+        'options': authors_options,
+        'bases': (models.Model,),
+    })()
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.models[('test_app', 'dataset')] = dataset_state
+    state.models[('test_app', 'project')] = project_state
+    state.models[('test_app', 'projectdataset')] = projectdataset_state
+    state.models[('test_app', 'authors')] = authors_state
+    
+    return state
+
+def test_manual_migration():
+    print("=== Testing Manual Migration ===")
+    
+    # Create initial state
+    print("1. Creating initial model state...")
+    initial_state = create_initial_models()
+    
+    # Create migration with both operations that should be generated
+    print("2. Creating migration with field change and unique_together removal...")
+    
+    # This is what the migration should look like based on the PR description
+    migration = type('Migration', (), {
+        'dependencies': [],
+        'operations': [
+            # Remove the unique_together constraint
+            migrations.AlterUniqueTogether(
+                name='authors',
+                unique_together=set(),
+            ),
+            # Remove the old ForeignKey field
+            migrations.RemoveField(
+                model_name='authors',
+                name='project_data_set',
+            ),
+            # Add the new ManyToManyField
+            migrations.AddField(
+                model_name='authors',
+                name='project_data_set',
+                field=models.ManyToManyField('test_app.ProjectDataSet'),
+            ),
+        ],
+    })()
+    
+    # Create executor and apply the migration
+    print("3. Applying migration...")
+    try:
+        executor = MigrationExecutor(connection)
+        executor.migrate([("test_app", "migration")])
+        print("   Migration applied successfully!")
+        return True
+    except Exception as e:
+        print(f"   Error applying migration: {e}")
+        return False
+
+if __name__ == '__main__':
+    # Change to the testbed directory
+    os.chdir('/testbed')
+    
+    # Add current directory to Python path
+    sys.path.insert(0, '/testbed')
+    
+    from django.db import connection
+    
+    success = test_manual_migration()
+    if not success:
+        print("\n=== Issue reproduced! ===")
+        sys.exit(1)
+    else:
+        print("\n=== No issue found ===")
+        sys.exit(0)
\ No newline at end of file
diff --git a/test_migration_direct.py b/test_migration_direct.py
new file mode 100644
index 0000000000..2f3e8ad5cc
--- /dev/null
+++ b/test_migration_direct.py
@@ -0,0 +1,269 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test_app',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models, migrations
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+from django.db.migrations.writer import MigrationWriter
+
+def create_initial_model_states():
+    """Create the initial model states (before the change)"""
+    
+    # DataSet model
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = ModelState(
+        app_label='test_app',
+        name='DataSet',
+        fields=dataset_fields,
+        options=dataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = ModelState(
+        app_label='test_app',
+        name='Project',
+        fields=project_fields,
+        options=project_options,
+        bases=(models.Model,),
+    )
+    
+    # ProjectDataSet model
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = ModelState(
+        app_label='test_app',
+        name='ProjectDataSet',
+        fields=projectdataset_fields,
+        options=projectdataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Authors model (with ForeignKey)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ForeignKey('test_app.ProjectDataSet', on_delete=models.PROTECT)),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {
+        'unique_together': {('project_data_set', 'state', 'start_date')},
+    }
+    authors_state = ModelState(
+        app_label='test_app',
+        name='Authors',
+        fields=authors_fields,
+        options=authors_options,
+        bases=(models.Model,),
+    )
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.add_model(dataset_state)
+    state.add_model(project_state)
+    state.add_model(projectdataset_state)
+    state.add_model(authors_state)
+    
+    return state
+
+def create_final_model_states():
+    """Create the final model states (after the change)"""
+    
+    # DataSet model (unchanged)
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = ModelState(
+        app_label='test_app',
+        name='DataSet',
+        fields=dataset_fields,
+        options=dataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = ModelState(
+        app_label='test_app',
+        name='Project',
+        fields=project_fields,
+        options=project_options,
+        bases=(models.Model,),
+    )
+    
+    # ProjectDataSet model (unchanged)
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = ModelState(
+        app_label='test_app',
+        name='ProjectDataSet',
+        fields=projectdataset_fields,
+        options=projectdataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Authors model (with ManyToManyField and no unique_together)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ManyToManyField('test_app.ProjectDataSet')),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {}  # unique_together removed
+    authors_state = ModelState(
+        app_label='test_app',
+        name='Authors',
+        fields=authors_fields,
+        options=authors_options,
+        bases=(models.Model,),
+    )
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.add_model(dataset_state)
+    state.add_model(project_state)
+    state.add_model(projectdataset_state)
+    state.add_model(authors_state)
+    
+    return state
+
+def test_migration_generation():
+    print("=== Testing Migration Generation ===")
+    
+    # Create initial and final states
+    print("1. Creating initial and final model states...")
+    from_state = create_initial_model_states()
+    to_state = create_final_model_states()
+    
+    # Debug: Let's check the fields in both states
+    print("   Debug - Initial Authors model fields:")
+    initial_authors = from_state.models[('test_app', 'authors')]
+    for name, field in initial_authors.fields.items():
+        print(f"     {name}: {field.__class__.__name__} (m2m: {field.many_to_many})")
+    
+    print("   Debug - Final Authors model fields:")
+    final_authors = to_state.models[('test_app', 'authors')]
+    for name, field in final_authors.fields.items():
+        print(f"     {name}: {field.__class__.__name__} (m2m: {field.many_to_many})")
+    
+    # Create autodetector and generate changes
+    print("2. Generating migration changes...")
+    autodetector = MigrationAutodetector(from_state, to_state)
+    
+    # Call _detect_changes to initialize the field keys
+    changes = autodetector._detect_changes()
+    
+    # Debug: Let's check what fields the autodetector thinks are altered
+    print("   Debug - Altered field keys:")
+    print(f"     Old field keys: {autodetector.old_field_keys}")
+    print(f"     New field keys: {autodetector.new_field_keys}")
+    print(f"     Kept field keys (intersection): {autodetector.old_field_keys & autodetector.new_field_keys}")
+    
+    # Debug: Check if project_data_set field is in the kept field keys
+    authors_field_key = ('test_app', 'authors', 'project_data_set')
+    print(f"   Debug - Authors project_data_set field in kept keys: {authors_field_key in (autodetector.old_field_keys & autodetector.new_field_keys)}")
+    
+    # Debug: Let's manually check if the field deconstruction is different
+    if authors_field_key in (autodetector.old_field_keys & autodetector.new_field_keys):
+        old_field = autodetector.from_state.models['test_app', 'authors'].get_field('project_data_set')
+        new_field = autodetector.to_state.models['test_app', 'authors'].get_field('project_data_set')
+        old_field_dec = autodetector.deep_deconstruct(old_field)
+        new_field_dec = autodetector.deep_deconstruct(new_field)
+        print(f"   Debug - Field deconstruction comparison:")
+        print(f"     Old field deconstruction: {old_field_dec}")
+        print(f"     New field deconstruction: {new_field_dec}")
+        print(f"     Fields are different: {old_field_dec != new_field_dec}")
+    
+    print("3. Generated changes:")
+    for app_label, app_migrations in changes.items():
+        print(f"   App: {app_label}")
+        for migration in app_migrations:
+            print(f"     Migration: {migration.name}")
+            print("     Operations:")
+            for operation in migration.operations:
+                print(f"       - {operation.__class__.__name__}: {operation}")
+    
+    # Try to write the migration
+    print("4. Writing migration...")
+    if 'test_app' in changes and changes['test_app']:
+        migration = changes['test_app'][0]
+        try:
+            writer = MigrationWriter(migration)
+            migration_string = writer.as_string()
+            print("   Migration written successfully!")
+            print("   Migration content:")
+            print(migration_string)
+            return True
+        except Exception as e:
+            print(f"   Error writing migration: {e}")
+            return False
+    else:
+        print("   No changes detected!")
+        return False
+
+if __name__ == '__main__':
+    # Change to the testbed directory
+    os.chdir('/testbed')
+    
+    # Add current directory to Python path
+    sys.path.insert(0, '/testbed')
+    
+    success = test_migration_generation()
+    if not success:
+        print("\n=== Issue reproduced! ===")
+        sys.exit(1)
+    else:
+        print("\n=== Migration generated successfully ===")
+        sys.exit(0)
\ No newline at end of file
diff --git a/test_migration_issue.py b/test_migration_issue.py
new file mode 100644
index 0000000000..14f021476f
--- /dev/null
+++ b/test_migration_issue.py
@@ -0,0 +1,172 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Create test_app directory first
+os.makedirs('test_app', exist_ok=True)
+with open('test_app/__init__.py', 'w') as f:
+    f.write('')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test_app',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import connection, migrations, transaction
+from django.core.management import execute_from_command_line
+from django.db.migrations.executor import MigrationExecutor
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState
+from django.db.migrations.writer import MigrationWriter
+
+# Create the test app models
+def create_initial_models():
+    models_code = '''
+from django.db import models
+
+class DataSet(models.Model):
+    name = models.TextField(max_length=50)
+
+class Project(models.Model):
+    data_sets = models.ManyToManyField(
+        DataSet,
+        through='ProjectDataSet',
+    )
+    name = models.TextField(max_length=50)
+
+class ProjectDataSet(models.Model):
+    """
+    Cross table of data set and project
+    """
+    data_set = models.ForeignKey(DataSet, on_delete=models.PROTECT)
+    project = models.ForeignKey(Project, on_delete=models.PROTECT)
+    class Meta:
+        unique_together = (('data_set', 'project'),)
+
+class Authors(models.Model):
+    project_data_set = models.ForeignKey(
+        ProjectDataSet,
+        on_delete=models.PROTECT
+    )
+    state = models.IntegerField()
+    start_date = models.DateField()
+    class Meta:
+        unique_together = (('project_data_set', 'state', 'start_date'),)
+'''
+    
+    # Create models.py
+    with open('test_app/models.py', 'w') as f:
+        f.write(models_code)
+    
+    # Create migrations directory
+    os.makedirs('test_app/migrations', exist_ok=True)
+    with open('test_app/migrations/__init__.py', 'w') as f:
+        f.write('')
+
+def create_modified_models():
+    models_code = '''
+from django.db import models
+
+class DataSet(models.Model):
+    name = models.TextField(max_length=50)
+
+class Project(models.Model):
+    data_sets = models.ManyToManyField(
+        DataSet,
+        through='ProjectDataSet',
+    )
+    name = models.TextField(max_length=50)
+
+class ProjectDataSet(models.Model):
+    """
+    Cross table of data set and project
+    """
+    data_set = models.ForeignKey(DataSet, on_delete=models.PROTECT)
+    project = models.ForeignKey(Project, on_delete=models.PROTECT)
+    class Meta:
+        unique_together = (('data_set', 'project'),)
+
+class Authors(models.Model):
+    project_data_set = models.ManyToManyField(
+        ProjectDataSet,
+    )
+    state = models.IntegerField()
+    start_date = models.DateField()
+'''
+    
+    with open('test_app/models.py', 'w') as f:
+        f.write(models_code)
+
+def test_migration_issue():
+    print("=== Testing Migration Issue ===")
+    
+    # Step 1: Create initial models
+    print("1. Creating initial models...")
+    create_initial_models()
+    
+    # Step 2: Create initial migration
+    print("2. Creating initial migration...")
+    execute_from_command_line(['manage.py', 'makemigrations', 'test_app'])
+    
+    # Step 3: Run initial migration
+    print("3. Running initial migration...")
+    execute_from_command_line(['manage.py', 'migrate'])
+    
+    # Step 4: Modify models (ForeignKey to ManyToManyField + remove unique_together)
+    print("4. Modifying models...")
+    create_modified_models()
+    
+    # Clear Django's model cache to pick up the changes
+    from django.apps import apps
+    apps.clear_cache()
+    
+    # Step 5: Create migration for the changes
+    print("5. Creating migration for changes...")
+    try:
+        execute_from_command_line(['manage.py', 'makemigrations', 'test_app'])
+        print("   Migration created successfully!")
+    except Exception as e:
+        print(f"   Error creating migration: {e}")
+        return False
+    
+    # Step 6: Try to run the migration
+    print("6. Running the migration...")
+    try:
+        execute_from_command_line(['manage.py', 'migrate'])
+        print("   Migration ran successfully!")
+        return True
+    except Exception as e:
+        print(f"   Error running migration: {e}")
+        return False
+
+if __name__ == '__main__':
+    # Change to the testbed directory
+    os.chdir('/testbed')
+    
+    # Add current directory to Python path
+    sys.path.insert(0, '/testbed')
+    
+    success = test_migration_issue()
+    if not success:
+        print("\n=== Issue reproduced! ===")
+        sys.exit(1)
+    else:
+        print("\n=== No issue found ===")
+        sys.exit(0)
\ No newline at end of file
diff --git a/test_migration_write.py b/test_migration_write.py
new file mode 100644
index 0000000000..e48f963c1a
--- /dev/null
+++ b/test_migration_write.py
@@ -0,0 +1,232 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test_app',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+from django.db.migrations.writer import MigrationWriter
+
+def create_initial_model_states():
+    """Create the initial model states (before the change)"""
+    
+    # DataSet model
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = ModelState(
+        app_label='test_app',
+        name='DataSet',
+        fields=dataset_fields,
+        options=dataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = ModelState(
+        app_label='test_app',
+        name='Project',
+        fields=project_fields,
+        options=project_options,
+        bases=(models.Model,),
+    )
+    
+    # ProjectDataSet model
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = ModelState(
+        app_label='test_app',
+        name='ProjectDataSet',
+        fields=projectdataset_fields,
+        options=projectdataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Authors model (with ForeignKey)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ForeignKey('test_app.ProjectDataSet', on_delete=models.PROTECT)),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {
+        'unique_together': {('project_data_set', 'state', 'start_date')},
+    }
+    authors_state = ModelState(
+        app_label='test_app',
+        name='Authors',
+        fields=authors_fields,
+        options=authors_options,
+        bases=(models.Model,),
+    )
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.add_model(dataset_state)
+    state.add_model(project_state)
+    state.add_model(projectdataset_state)
+    state.add_model(authors_state)
+    
+    return state
+
+def create_final_model_states():
+    """Create the final model states (after the change)"""
+    
+    # DataSet model (unchanged)
+    dataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+    ]
+    dataset_options = {}
+    dataset_state = ModelState(
+        app_label='test_app',
+        name='DataSet',
+        fields=dataset_fields,
+        options=dataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Project model
+    project_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.TextField(max_length=50)),
+        ('data_sets', models.ManyToManyField('test_app.DataSet', through='test_app.ProjectDataSet')),
+    ]
+    project_options = {}
+    project_state = ModelState(
+        app_label='test_app',
+        name='Project',
+        fields=project_fields,
+        options=project_options,
+        bases=(models.Model,),
+    )
+    
+    # ProjectDataSet model (unchanged)
+    projectdataset_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('data_set', models.ForeignKey('test_app.DataSet', on_delete=models.PROTECT)),
+        ('project', models.ForeignKey('test_app.Project', on_delete=models.PROTECT)),
+    ]
+    projectdataset_options = {
+        'unique_together': {('data_set', 'project')},
+    }
+    projectdataset_state = ModelState(
+        app_label='test_app',
+        name='ProjectDataSet',
+        fields=projectdataset_fields,
+        options=projectdataset_options,
+        bases=(models.Model,),
+    )
+    
+    # Authors model (with ManyToManyField and no unique_together)
+    authors_fields = [
+        ('id', models.AutoField(primary_key=True)),
+        ('project_data_set', models.ManyToManyField('test_app.ProjectDataSet')),
+        ('state', models.IntegerField()),
+        ('start_date', models.DateField()),
+    ]
+    authors_options = {}  # unique_together removed
+    authors_state = ModelState(
+        app_label='test_app',
+        name='Authors',
+        fields=authors_fields,
+        options=authors_options,
+        bases=(models.Model,),
+    )
+    
+    # Create ProjectState and add models
+    state = ProjectState()
+    state.add_model(dataset_state)
+    state.add_model(project_state)
+    state.add_model(projectdataset_state)
+    state.add_model(authors_state)
+    
+    return state
+
+def test_migration_write():
+    print("=== Testing Migration Write ===")
+    
+    # Create initial and final states
+    from_state = create_initial_model_states()
+    to_state = create_final_model_states()
+    
+    # Create autodetector and generate changes
+    autodetector = MigrationAutodetector(from_state, to_state)
+    changes = autodetector._detect_changes()
+    
+    print("Generated changes:")
+    for app_label, app_migrations in changes.items():
+        print(f"App: {app_label}")
+        for migration in app_migrations:
+            print(f"  Migration: {migration.name}")
+            print("  Operations:")
+            for i, operation in enumerate(migration.operations):
+                print(f"    {i}: {operation.__class__.__name__} - {operation}")
+    
+    # Try to write the migration
+    if 'test_app' in changes and changes['test_app']:
+        migration = changes['test_app'][0]
+        try:
+            writer = MigrationWriter(migration)
+            migration_string = writer.as_string()
+            print("‚úÖ Migration written successfully!")
+            print("Migration content:")
+            print(migration_string)
+            return True
+        except Exception as e:
+            print(f"‚ùå Error writing migration: {e}")
+            return False
+    else:
+        print("‚ùå No changes generated")
+        return False
+
+if __name__ == '__main__':
+    # Change to the testbed directory
+    os.chdir('/testbed')
+    
+    # Add current directory to Python path
+    sys.path.insert(0, '/testbed')
+    
+    success = test_migration_write()
+    if not success:
+        print("\n=== Migration write failed ===")
+        sys.exit(1)
+    else:
+        print("\n=== Migration write succeeded! ===")
+        sys.exit(0)
\ No newline at end of file
