{"model_name_or_path": "vllm_local__--data--models--GLM-4.5-FP8__t-0.00__p-1.00__c-0.00___swe_bench_lite_test__bs32", "instance_id": "django__django-16910", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..919d0070c1 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1250,7 +1250,10 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                # For reverse OneToOneField relations, the mask is stored using the\n+                # forward field object, so we need to use related_field.remote_field\n+                # to look up the mask correctly.\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\ndiff --git a/tests/select_related_onetoone/tests.py b/tests/select_related_onetoone/tests.py\nindex 8bdfb83fe8..82d3904d7a 100644\n--- a/tests/select_related_onetoone/tests.py\n+++ b/tests/select_related_onetoone/tests.py\n@@ -259,6 +259,41 @@ class ReverseSelectRelatedTestCase(TestCase):\n             item1_db = LinkedList.objects.select_related(\"next_item\").get(name=\"item1\")\n             self.assertEqual(item1_db.next_item.name, \"item2\")\n \n+    def test_only_with_select_related_on_reverse_onetoone(self):\n+        \"\"\"\n+        Test that only() works correctly with select_related() on reverse OneToOneField.\n+        This is a regression test for the issue where only() with select_related()\n+        on a reverse OneToOneField relation would include all fields from the related\n+        model instead of only the specified fields.\n+        \"\"\"\n+        # Create test data similar to the PR description\n+        user = User.objects.create(username=\"test_user\")\n+        user_profile = UserProfile.objects.create(\n+            user=user, city=\"Test City\", state=\"TS\"\n+        )\n+        \n+        # Test the problematic query: select_related with only on reverse OneToOneField\n+        queryset = User.objects.select_related('userprofile').only(\n+            'username', 'userprofile__city'\n+        )\n+        \n+        # Verify that only the specified fields are loaded by checking the SQL\n+        sql, params = queryset.query.sql_with_params()\n+        self.assertIn('username', sql)\n+        self.assertIn('city', sql)\n+        # Ensure that the unspecified 'state' field is NOT in the SQL\n+        self.assertNotIn('state', sql)\n+        \n+        # Now execute the query to verify it works correctly\n+        with self.assertNumQueries(1):\n+            result = queryset.get(username=\"test_user\")\n+            \n+            # Check that the main object fields are loaded correctly\n+            self.assertEqual(result.username, \"test_user\")\n+            \n+            # Check that the related object fields are loaded correctly\n+            self.assertEqual(result.userprofile.city, \"Test City\")\n+\n \n class ReverseSelectRelatedValidationTests(SimpleTestCase):\n     \"\"\"\n"}