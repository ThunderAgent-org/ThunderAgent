{"model_name_or_path": "vllm_local__--data--models--GLM-4.5-FP8__t-0.00__p-1.00__c-0.00___swe_bench_lite_test__bs4", "instance_id": "django__django-14016", "model_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..1cb97d8659 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -8,7 +8,9 @@ circular import difficulties.\n import copy\n import functools\n import inspect\n+import pickle\n from collections import namedtuple\n+from types import GeneratorType\n \n from django.core.exceptions import FieldError\n from django.db.models.constants import LOOKUP_SEP\n@@ -40,16 +42,73 @@ class Q(tree.Node):\n     def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n+    def _safe_deepcopy(self):\n+        \"\"\"\n+        Create a deep copy of this Q object, converting non-pickleable objects \n+        to pickleable equivalents.\n+        \"\"\"\n+        def make_pickleable(obj):\n+            \"\"\"\n+            Convert non-pickleable objects to pickleable equivalents.\n+            \"\"\"\n+            # Handle dict_keys, dict_values, dict_items\n+            if hasattr(obj, '__iter__') and hasattr(obj, '__reversed__') and not isinstance(obj, (str, bytes, list, tuple, set, frozenset, dict)):\n+                # This covers dict_keys, dict_values, dict_items and other dict views\n+                try:\n+                    return list(obj)\n+                except (TypeError, ValueError):\n+                    pass\n+            \n+            # Handle generators and other iterators\n+            if isinstance(obj, GeneratorType):\n+                try:\n+                    return list(obj)\n+                except (TypeError, ValueError):\n+                    pass\n+            \n+            # For other objects, try to copy them normally\n+            try:\n+                return copy.deepcopy(obj)\n+            except (TypeError, pickle.PickleError, AttributeError):\n+                # If deepcopy fails, try to convert to a basic type\n+                if hasattr(obj, '__iter__'):\n+                    try:\n+                        return list(obj)\n+                    except (TypeError, ValueError):\n+                        pass\n+                # If all else fails, return the object as-is\n+                return obj\n+        \n+        # Create a new Q object with the same connector and negated values\n+        obj = type(self)(_connector=self.connector, _negated=self.negated)\n+        \n+        # Copy children, making them pickleable\n+        for child in self.children:\n+            if isinstance(child, Q):\n+                # Recursively copy Q objects\n+                obj.children.append(child._safe_deepcopy())\n+            elif isinstance(child, tuple) and len(child) == 2:\n+                # Handle field lookup tuples like ('field__in', some_value)\n+                field, value = child\n+                pickleable_value = make_pickleable(value)\n+                obj.children.append((field, pickleable_value))\n+            else:\n+                # Handle other types of children\n+                pickleable_child = make_pickleable(child)\n+                obj.children.append(pickleable_child)\n+        \n+        return obj\n+\n     def _combine(self, other, conn):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n-            return copy.deepcopy(self)\n+            return self._safe_deepcopy()\n         # Or if this Q is empty, ignore it and just use `other`.\n         elif not self:\n-            return copy.deepcopy(other)\n+            return other._safe_deepcopy()\n \n         obj = type(self)()\n         obj.connector = conn\n"}