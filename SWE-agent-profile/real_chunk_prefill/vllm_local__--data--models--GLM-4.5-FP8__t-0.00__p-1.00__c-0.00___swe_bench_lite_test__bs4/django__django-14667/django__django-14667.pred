{"model_name_or_path": "vllm_local__--data--models--GLM-4.5-FP8__t-0.00__p-1.00__c-0.00___swe_bench_lite_test__bs4", "instance_id": "django__django-14667", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..18ba0607c9 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -225,6 +225,8 @@ class Query(BaseExpression):\n         # are the fields to defer, or False if these are the only fields to\n         # load.\n         self.deferred_loading = (frozenset(), True)\n+        # Flag to track when we've transitioned from only() to defer()\n+        self._defer_all_after_only = False\n \n         self._filtered_relations = {}\n \n@@ -679,6 +681,14 @@ class Query(BaseExpression):\n         \"\"\"\n         field_names, defer = self.deferred_loading\n         if not field_names:\n+            if defer:\n+                # Empty field_names with defer=True means \"defer all fields except\n+                # the default ones (like pk)\". We need to handle this case by\n+                # setting up the callback to only include the must_include fields.\n+                orig_opts = self.get_meta()\n+                must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n+                for model, values in must_include.items():\n+                    callback(target, model, values)\n             return\n         orig_opts = self.get_meta()\n         seen = {}\n@@ -730,6 +740,26 @@ class Query(BaseExpression):\n                 # \"else\" branch here.\n                 if model in workset:\n                     workset[model].update(values)\n+                else:\n+                    # If workset is empty for this model, it means we want to\n+                    # load only the must_include fields (typically just the pk).\n+                    workset[model] = values\n+            \n+            # Special case: if field_names contains all the fields that would normally\n+            # be loaded, it means we want to defer all fields and only load the\n+            # must_include fields (typically just the pk).\n+            # This handles cases like only().defer().defer() where we want to\n+            # defer all fields including additional ones.\n+            if workset and field_names:\n+                all_model_fields = set()\n+                for model in workset:\n+                    all_model_fields.update(model._meta.local_fields)\n+                if field_names.issuperset(f.name for f in all_model_fields if not is_reverse_o2o(f)):\n+                    # All fields are being deferred, so only load must_include fields\n+                    workset = {}\n+                    for model, values in must_include.items():\n+                        workset[model] = values\n+            \n             for model, values in workset.items():\n                 callback(target, model, values)\n         else:\n@@ -2082,11 +2112,23 @@ class Query(BaseExpression):\n         # get_columns()).\n         existing, defer = self.deferred_loading\n         if defer:\n-            # Add to existing deferred names.\n-            self.deferred_loading = existing.union(field_names), True\n+            if self._defer_all_after_only:\n+                # We're in the state where we want to defer all fields after only().defer()\n+                # Keep the state as \"defer all fields except default ones\"\n+                self.deferred_loading = frozenset(), True\n+            else:\n+                # Add to existing deferred names.\n+                self.deferred_loading = existing.union(field_names), True\n         else:\n             # Remove names from the set of any existing \"immediate load\" names.\n-            self.deferred_loading = existing.difference(field_names), False\n+            result = existing.difference(field_names)\n+            # If the result is an empty set, it means we want to defer all fields\n+            # except the default ones (like pk), so we should set defer=True.\n+            if not result:\n+                self.deferred_loading = frozenset(), True\n+                self._defer_all_after_only = True  # Mark that we transitioned from only() to defer()\n+            else:\n+                self.deferred_loading = result, False\n \n     def add_immediate_loading(self, field_names):\n         \"\"\"\n@@ -2105,12 +2147,17 @@ class Query(BaseExpression):\n             field_names.add(self.get_meta().pk.name)\n \n         if defer:\n-            # Remove any existing deferred names from the current set before\n-            # setting the new names.\n-            self.deferred_loading = field_names.difference(existing), False\n+            # When we have deferred fields and call only(), we want to load\n+            # only the specified fields, not all fields. The existing logic\n+            # of removing deferred names from field_names doesn't make sense\n+            # in this context.\n+            self.deferred_loading = frozenset(field_names), False\n         else:\n             # Replace any existing \"immediate load\" field names.\n             self.deferred_loading = frozenset(field_names), False\n+        \n+        # Reset the flag since we're setting immediate loading fields\n+        self._defer_all_after_only = False\n \n     def get_loaded_field_names(self):\n         \"\"\"\n"}