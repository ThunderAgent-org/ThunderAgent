{"model_name_or_path": "vllm_local__--data--models--GLM-4.5-FP8__t-0.00__p-1.00__c-0.00___swe_bench_lite_test__bs4", "instance_id": "django__django-15996", "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..93a2f927f6 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -125,10 +125,50 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        return (\n-            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n-            {\"import %s\" % module},\n-        )\n+        \n+        # Check if this is a single enum value with a valid name\n+        if self.value.name is not None:\n+            return (\n+                \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n+                {\"import %s\" % module},\n+            )\n+        else:\n+            # This is a combination of enum flags, decompose it\n+            members, not_covered = enum._decompose(enum_class, self.value.value)\n+            \n+            if not_covered != 0:\n+                # If there are uncovered bits, we can't properly serialize this\n+                raise ValueError(\n+                    \"Cannot serialize enum value %r: unable to decompose value %d\" % \n+                    (self.value, self.value.value)\n+                )\n+            \n+            # Check if any member has name=None (this can happen with zero values or other edge cases)\n+            if any(member.name is None for member in members):\n+                # If we have a zero value, we can't serialize it meaningfully\n+                if self.value.value == 0:\n+                    raise ValueError(\n+                        \"Cannot serialize enum value %r: zero-value enums cannot be serialized\" % \n+                        (self.value,)\n+                    )\n+                else:\n+                    # This shouldn't happen if not_covered is 0, but let's be safe\n+                    raise ValueError(\n+                        \"Cannot serialize enum value %r: decomposed members include unnamed values\" % \n+                        (self.value,)\n+                    )\n+            \n+            # Generate the expression by combining the members with |\n+            parts = []\n+            for member in members:\n+                parts.append(\"%s.%s[%r]\" % (module, enum_class.__qualname__, member.name))\n+            \n+            if len(parts) == 1:\n+                expression = parts[0]\n+            else:\n+                expression = \" | \".join(parts)\n+            \n+            return expression, {\"import %s\" % module}\n \n \n class FloatSerializer(BaseSimpleSerializer):\ndiff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex bad8775d4e..bca4039eaf 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -402,6 +402,18 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+        # Test combined enum flags (the main fix for this PR)\n+        combined_flags = IntFlagEnum.A | IntFlagEnum.B\n+        self.assertSerializedResultEqual(\n+            combined_flags,\n+            (\n+                \"migrations.test_writer.IntFlagEnum['A'] | migrations.test_writer.IntFlagEnum['B']\",\n+                {\"import migrations.test_writer\"},\n+            ),\n+        )\n+        # Test that combined flags can be round-tripped\n+        self.assertSerializedEqual(combined_flags)\n+        \n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n@@ -413,6 +425,14 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+        \n+        # Test field with combined enum flags as default\n+        field_with_combined_default = models.IntegerField(default=combined_flags)\n+        combined_string = MigrationWriter.serialize(field_with_combined_default)[0]\n+        self.assertEqual(\n+            combined_string,\n+            \"models.IntegerField(default=migrations.test_writer.IntFlagEnum['A'] | migrations.test_writer.IntFlagEnum['B'])\",\n+        )\n \n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n"}