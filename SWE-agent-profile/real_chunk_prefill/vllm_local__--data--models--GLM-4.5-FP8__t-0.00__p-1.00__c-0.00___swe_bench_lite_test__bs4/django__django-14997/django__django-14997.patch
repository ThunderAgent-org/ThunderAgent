diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py
index febaadbb5b..145d2b86a7 100644
--- a/django/db/models/fields/related.py
+++ b/django/db/models/fields/related.py
@@ -1206,6 +1206,9 @@ class ManyToManyField(RelatedField):
 
         self.db_table = db_table
         self.swappable = swappable
+        
+        # Store the original user-provided related_name for validation
+        self._user_provided_related_name = related_name
 
     def check(self, **kwargs):
         return [
@@ -1214,6 +1217,7 @@ class ManyToManyField(RelatedField):
             *self._check_relationship_model(**kwargs),
             *self._check_ignored_options(**kwargs),
             *self._check_table_uniqueness(**kwargs),
+            *self._check_symmetrical_related_name(**kwargs),
         ]
 
     def _check_unique(self, **kwargs):
@@ -1453,6 +1457,36 @@ class ManyToManyField(RelatedField):
 
         return errors
 
+    def _check_symmetrical_related_name(self, **kwargs):
+        """
+        Check that related_name is not used with symmetrical ManyToManyFields.
+        
+        For symmetrical relationships, the related field on the target model
+        is not created, so using related_name is confusing and should be prevented.
+        
+        The exception is related_name='+', which explicitly disables the reverse
+        relation and is allowed even on symmetrical fields.
+        """
+        errors = []
+        
+        # Check if the relation is symmetrical
+        if self.remote_field.symmetrical:
+            # Check if a related_name was provided by the user
+            # Allow related_name='+' since it explicitly disables reverse relation
+            if (self._user_provided_related_name is not None and 
+                self._user_provided_related_name != '+'):
+                errors.append(
+                    checks.Error(
+                        "'related_name' cannot be set on a symmetrical ManyToManyField.",
+                        hint="Symmetrical ManyToManyFields do not create a reverse "
+                             "relation, so 'related_name' has no effect.",
+                        obj=self,
+                        id='fields.E335',
+                    )
+                )
+        
+        return errors
+
     def _check_table_uniqueness(self, **kwargs):
         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
             return []
