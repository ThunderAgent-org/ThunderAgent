diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py
index c2623f099f..1cb97d8659 100644
--- a/django/db/models/query_utils.py
+++ b/django/db/models/query_utils.py
@@ -8,7 +8,9 @@ circular import difficulties.
 import copy
 import functools
 import inspect
+import pickle
 from collections import namedtuple
+from types import GeneratorType
 
 from django.core.exceptions import FieldError
 from django.db.models.constants import LOOKUP_SEP
@@ -40,16 +42,73 @@ class Q(tree.Node):
     def __init__(self, *args, _connector=None, _negated=False, **kwargs):
         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)
 
+    def _safe_deepcopy(self):
+        """
+        Create a deep copy of this Q object, converting non-pickleable objects 
+        to pickleable equivalents.
+        """
+        def make_pickleable(obj):
+            """
+            Convert non-pickleable objects to pickleable equivalents.
+            """
+            # Handle dict_keys, dict_values, dict_items
+            if hasattr(obj, '__iter__') and hasattr(obj, '__reversed__') and not isinstance(obj, (str, bytes, list, tuple, set, frozenset, dict)):
+                # This covers dict_keys, dict_values, dict_items and other dict views
+                try:
+                    return list(obj)
+                except (TypeError, ValueError):
+                    pass
+            
+            # Handle generators and other iterators
+            if isinstance(obj, GeneratorType):
+                try:
+                    return list(obj)
+                except (TypeError, ValueError):
+                    pass
+            
+            # For other objects, try to copy them normally
+            try:
+                return copy.deepcopy(obj)
+            except (TypeError, pickle.PickleError, AttributeError):
+                # If deepcopy fails, try to convert to a basic type
+                if hasattr(obj, '__iter__'):
+                    try:
+                        return list(obj)
+                    except (TypeError, ValueError):
+                        pass
+                # If all else fails, return the object as-is
+                return obj
+        
+        # Create a new Q object with the same connector and negated values
+        obj = type(self)(_connector=self.connector, _negated=self.negated)
+        
+        # Copy children, making them pickleable
+        for child in self.children:
+            if isinstance(child, Q):
+                # Recursively copy Q objects
+                obj.children.append(child._safe_deepcopy())
+            elif isinstance(child, tuple) and len(child) == 2:
+                # Handle field lookup tuples like ('field__in', some_value)
+                field, value = child
+                pickleable_value = make_pickleable(value)
+                obj.children.append((field, pickleable_value))
+            else:
+                # Handle other types of children
+                pickleable_child = make_pickleable(child)
+                obj.children.append(pickleable_child)
+        
+        return obj
+
     def _combine(self, other, conn):
         if not isinstance(other, Q):
             raise TypeError(other)
 
         # If the other Q() is empty, ignore it and just use `self`.
         if not other:
-            return copy.deepcopy(self)
+            return self._safe_deepcopy()
         # Or if this Q is empty, ignore it and just use `other`.
         elif not self:
-            return copy.deepcopy(other)
+            return other._safe_deepcopy()
 
         obj = type(self)()
         obj.connector = conn
