{
  "sympy__sympy-20442": {
    "model_name_or_path": "zai-org/GLM-4.6-FP8",
    "instance_id": "sympy__sympy-20442",
    "model_patch": "diff --git a/sympy/physics/units/util.py b/sympy/physics/units/util.py\nindex b03ed4cd88..87d60e7d73 100644\n--- a/sympy/physics/units/util.py\n+++ b/sympy/physics/units/util.py\n@@ -30,8 +30,24 @@ def _get_conversion_matrix_for_expr(expr, target_units, unit_system):\n     camat = Matrix([[dimension_system.get_dimensional_dependencies(i, mark_dimensionless=True).get(j, 0) for i in target_dims] for j in canon_dim_units])\n     exprmat = Matrix([dim_dependencies.get(k, 0) for k in canon_dim_units])\n \n-    res_exponents = camat.solve_least_squares(exprmat, method=None)\n-    return res_exponents\n+    # Check if we have a single target unit that's a compound unit\n+    # In this case, we need to check if the dimensions match exactly\n+    if len(target_units) == 1 and len(target_dims[0].args) > 1:\n+        # For a single compound target unit, check if dimensions match exactly\n+        if target_dims[0] != expr_dim:\n+            return None\n+    \n+    # Try to solve the system exactly first\n+    try:\n+        res_exponents = camat.gauss_jordan_solve(exprmat)[0]\n+        # Check if the solution is exact (no fractions that would indicate approximation)\n+        if all(val.is_Rational for val in res_exponents):\n+            return res_exponents\n+    except:\n+        pass\n+    \n+    # If exact solution fails, return None to indicate conversion is not possible\n+    return None\n \n \n def convert_to(expr, target_units, unit_system=\"SI\"):\n"
  }
}